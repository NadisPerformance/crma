module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateClient {
  count: Int!
}

type AggregateContact {
  count: Int!
}

type AggregateCountry {
  count: Int!
}

type AggregateDepartment {
  count: Int!
}

type AggregateDevisModele {
  count: Int!
}

type AggregateDocument {
  count: Int!
}

type AggregateDocumentType {
  count: Int!
}

type AggregateEmpInfo {
  count: Int!
}

type AggregateEmploye {
  count: Int!
}

type AggregateEntity {
  count: Int!
}

type AggregateFile {
  count: Int!
}

type AggregateJob {
  count: Int!
}

type AggregateLegalType {
  count: Int!
}

type AggregateMaction {
  count: Int!
}

type AggregateMovement {
  count: Int!
}

type AggregatePerson {
  count: Int!
}

type AggregateStructure {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Client {
  id: Int!
  type: Boolean
  createdAt: DateTime
  updatedAt: DateTime
  person: Person
  structure: Structure
}

type ClientConnection {
  pageInfo: PageInfo!
  edges: [ClientEdge]!
  aggregate: AggregateClient!
}

input ClientCreateInput {
  id: Int
  type: Boolean
  person: PersonCreateOneInput
  structure: StructureCreateOneInput
}

type ClientEdge {
  node: Client!
  cursor: String!
}

enum ClientOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ClientPreviousValues {
  id: Int!
  type: Boolean
  createdAt: DateTime
  updatedAt: DateTime
}

type ClientSubscriptionPayload {
  mutation: MutationType!
  node: Client
  updatedFields: [String!]
  previousValues: ClientPreviousValues
}

input ClientSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ClientWhereInput
  AND: [ClientSubscriptionWhereInput!]
  OR: [ClientSubscriptionWhereInput!]
  NOT: [ClientSubscriptionWhereInput!]
}

input ClientUpdateInput {
  type: Boolean
  person: PersonUpdateOneInput
  structure: StructureUpdateOneInput
}

input ClientUpdateManyMutationInput {
  type: Boolean
}

input ClientWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  type: Boolean
  type_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  person: PersonWhereInput
  structure: StructureWhereInput
  AND: [ClientWhereInput!]
  OR: [ClientWhereInput!]
  NOT: [ClientWhereInput!]
}

input ClientWhereUniqueInput {
  id: Int
}

type Contact {
  id: Int!
  activite: String
  adresse: String
  adresseComplement: String
  civilite: Boolean!
  comment: String
  companyName: String
  countryId: Int!
  cp: String
  created: DateTime
  email: String
  insertedId: Int
  lienSite: String
  nom: String!
  prenom: String
  structureId: Int
  tel1: String
  tel2: String
  ville: String
}

type ContactConnection {
  pageInfo: PageInfo!
  edges: [ContactEdge]!
  aggregate: AggregateContact!
}

input ContactCreateInput {
  id: Int
  activite: String
  adresse: String
  adresseComplement: String
  civilite: Boolean
  comment: String
  companyName: String
  countryId: Int
  cp: String
  created: DateTime
  email: String
  insertedId: Int
  lienSite: String
  nom: String!
  prenom: String
  structureId: Int
  tel1: String
  tel2: String
  ville: String
}

type ContactEdge {
  node: Contact!
  cursor: String!
}

enum ContactOrderByInput {
  id_ASC
  id_DESC
  activite_ASC
  activite_DESC
  adresse_ASC
  adresse_DESC
  adresseComplement_ASC
  adresseComplement_DESC
  civilite_ASC
  civilite_DESC
  comment_ASC
  comment_DESC
  companyName_ASC
  companyName_DESC
  countryId_ASC
  countryId_DESC
  cp_ASC
  cp_DESC
  created_ASC
  created_DESC
  email_ASC
  email_DESC
  insertedId_ASC
  insertedId_DESC
  lienSite_ASC
  lienSite_DESC
  nom_ASC
  nom_DESC
  prenom_ASC
  prenom_DESC
  structureId_ASC
  structureId_DESC
  tel1_ASC
  tel1_DESC
  tel2_ASC
  tel2_DESC
  ville_ASC
  ville_DESC
}

type ContactPreviousValues {
  id: Int!
  activite: String
  adresse: String
  adresseComplement: String
  civilite: Boolean!
  comment: String
  companyName: String
  countryId: Int!
  cp: String
  created: DateTime
  email: String
  insertedId: Int
  lienSite: String
  nom: String!
  prenom: String
  structureId: Int
  tel1: String
  tel2: String
  ville: String
}

type ContactSubscriptionPayload {
  mutation: MutationType!
  node: Contact
  updatedFields: [String!]
  previousValues: ContactPreviousValues
}

input ContactSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ContactWhereInput
  AND: [ContactSubscriptionWhereInput!]
  OR: [ContactSubscriptionWhereInput!]
  NOT: [ContactSubscriptionWhereInput!]
}

input ContactUpdateInput {
  activite: String
  adresse: String
  adresseComplement: String
  civilite: Boolean
  comment: String
  companyName: String
  countryId: Int
  cp: String
  created: DateTime
  email: String
  insertedId: Int
  lienSite: String
  nom: String
  prenom: String
  structureId: Int
  tel1: String
  tel2: String
  ville: String
}

input ContactUpdateManyMutationInput {
  activite: String
  adresse: String
  adresseComplement: String
  civilite: Boolean
  comment: String
  companyName: String
  countryId: Int
  cp: String
  created: DateTime
  email: String
  insertedId: Int
  lienSite: String
  nom: String
  prenom: String
  structureId: Int
  tel1: String
  tel2: String
  ville: String
}

input ContactWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  activite: String
  activite_not: String
  activite_in: [String!]
  activite_not_in: [String!]
  activite_lt: String
  activite_lte: String
  activite_gt: String
  activite_gte: String
  activite_contains: String
  activite_not_contains: String
  activite_starts_with: String
  activite_not_starts_with: String
  activite_ends_with: String
  activite_not_ends_with: String
  adresse: String
  adresse_not: String
  adresse_in: [String!]
  adresse_not_in: [String!]
  adresse_lt: String
  adresse_lte: String
  adresse_gt: String
  adresse_gte: String
  adresse_contains: String
  adresse_not_contains: String
  adresse_starts_with: String
  adresse_not_starts_with: String
  adresse_ends_with: String
  adresse_not_ends_with: String
  adresseComplement: String
  adresseComplement_not: String
  adresseComplement_in: [String!]
  adresseComplement_not_in: [String!]
  adresseComplement_lt: String
  adresseComplement_lte: String
  adresseComplement_gt: String
  adresseComplement_gte: String
  adresseComplement_contains: String
  adresseComplement_not_contains: String
  adresseComplement_starts_with: String
  adresseComplement_not_starts_with: String
  adresseComplement_ends_with: String
  adresseComplement_not_ends_with: String
  civilite: Boolean
  civilite_not: Boolean
  comment: String
  comment_not: String
  comment_in: [String!]
  comment_not_in: [String!]
  comment_lt: String
  comment_lte: String
  comment_gt: String
  comment_gte: String
  comment_contains: String
  comment_not_contains: String
  comment_starts_with: String
  comment_not_starts_with: String
  comment_ends_with: String
  comment_not_ends_with: String
  companyName: String
  companyName_not: String
  companyName_in: [String!]
  companyName_not_in: [String!]
  companyName_lt: String
  companyName_lte: String
  companyName_gt: String
  companyName_gte: String
  companyName_contains: String
  companyName_not_contains: String
  companyName_starts_with: String
  companyName_not_starts_with: String
  companyName_ends_with: String
  companyName_not_ends_with: String
  countryId: Int
  countryId_not: Int
  countryId_in: [Int!]
  countryId_not_in: [Int!]
  countryId_lt: Int
  countryId_lte: Int
  countryId_gt: Int
  countryId_gte: Int
  cp: String
  cp_not: String
  cp_in: [String!]
  cp_not_in: [String!]
  cp_lt: String
  cp_lte: String
  cp_gt: String
  cp_gte: String
  cp_contains: String
  cp_not_contains: String
  cp_starts_with: String
  cp_not_starts_with: String
  cp_ends_with: String
  cp_not_ends_with: String
  created: DateTime
  created_not: DateTime
  created_in: [DateTime!]
  created_not_in: [DateTime!]
  created_lt: DateTime
  created_lte: DateTime
  created_gt: DateTime
  created_gte: DateTime
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  insertedId: Int
  insertedId_not: Int
  insertedId_in: [Int!]
  insertedId_not_in: [Int!]
  insertedId_lt: Int
  insertedId_lte: Int
  insertedId_gt: Int
  insertedId_gte: Int
  lienSite: String
  lienSite_not: String
  lienSite_in: [String!]
  lienSite_not_in: [String!]
  lienSite_lt: String
  lienSite_lte: String
  lienSite_gt: String
  lienSite_gte: String
  lienSite_contains: String
  lienSite_not_contains: String
  lienSite_starts_with: String
  lienSite_not_starts_with: String
  lienSite_ends_with: String
  lienSite_not_ends_with: String
  nom: String
  nom_not: String
  nom_in: [String!]
  nom_not_in: [String!]
  nom_lt: String
  nom_lte: String
  nom_gt: String
  nom_gte: String
  nom_contains: String
  nom_not_contains: String
  nom_starts_with: String
  nom_not_starts_with: String
  nom_ends_with: String
  nom_not_ends_with: String
  prenom: String
  prenom_not: String
  prenom_in: [String!]
  prenom_not_in: [String!]
  prenom_lt: String
  prenom_lte: String
  prenom_gt: String
  prenom_gte: String
  prenom_contains: String
  prenom_not_contains: String
  prenom_starts_with: String
  prenom_not_starts_with: String
  prenom_ends_with: String
  prenom_not_ends_with: String
  structureId: Int
  structureId_not: Int
  structureId_in: [Int!]
  structureId_not_in: [Int!]
  structureId_lt: Int
  structureId_lte: Int
  structureId_gt: Int
  structureId_gte: Int
  tel1: String
  tel1_not: String
  tel1_in: [String!]
  tel1_not_in: [String!]
  tel1_lt: String
  tel1_lte: String
  tel1_gt: String
  tel1_gte: String
  tel1_contains: String
  tel1_not_contains: String
  tel1_starts_with: String
  tel1_not_starts_with: String
  tel1_ends_with: String
  tel1_not_ends_with: String
  tel2: String
  tel2_not: String
  tel2_in: [String!]
  tel2_not_in: [String!]
  tel2_lt: String
  tel2_lte: String
  tel2_gt: String
  tel2_gte: String
  tel2_contains: String
  tel2_not_contains: String
  tel2_starts_with: String
  tel2_not_starts_with: String
  tel2_ends_with: String
  tel2_not_ends_with: String
  ville: String
  ville_not: String
  ville_in: [String!]
  ville_not_in: [String!]
  ville_lt: String
  ville_lte: String
  ville_gt: String
  ville_gte: String
  ville_contains: String
  ville_not_contains: String
  ville_starts_with: String
  ville_not_starts_with: String
  ville_ends_with: String
  ville_not_ends_with: String
  AND: [ContactWhereInput!]
  OR: [ContactWhereInput!]
  NOT: [ContactWhereInput!]
}

input ContactWhereUniqueInput {
  id: Int
}

type Country {
  id: Int!
  code: String!
  name: String!
  ordre: Int!
}

type CountryConnection {
  pageInfo: PageInfo!
  edges: [CountryEdge]!
  aggregate: AggregateCountry!
}

input CountryCreateInput {
  id: Int
  code: String!
  name: String!
  ordre: Int
}

type CountryEdge {
  node: Country!
  cursor: String!
}

enum CountryOrderByInput {
  id_ASC
  id_DESC
  code_ASC
  code_DESC
  name_ASC
  name_DESC
  ordre_ASC
  ordre_DESC
}

type CountryPreviousValues {
  id: Int!
  code: String!
  name: String!
  ordre: Int!
}

type CountrySubscriptionPayload {
  mutation: MutationType!
  node: Country
  updatedFields: [String!]
  previousValues: CountryPreviousValues
}

input CountrySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CountryWhereInput
  AND: [CountrySubscriptionWhereInput!]
  OR: [CountrySubscriptionWhereInput!]
  NOT: [CountrySubscriptionWhereInput!]
}

input CountryUpdateInput {
  code: String
  name: String
  ordre: Int
}

input CountryUpdateManyMutationInput {
  code: String
  name: String
  ordre: Int
}

input CountryWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  code: String
  code_not: String
  code_in: [String!]
  code_not_in: [String!]
  code_lt: String
  code_lte: String
  code_gt: String
  code_gte: String
  code_contains: String
  code_not_contains: String
  code_starts_with: String
  code_not_starts_with: String
  code_ends_with: String
  code_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  ordre: Int
  ordre_not: Int
  ordre_in: [Int!]
  ordre_not_in: [Int!]
  ordre_lt: Int
  ordre_lte: Int
  ordre_gt: Int
  ordre_gte: Int
  AND: [CountryWhereInput!]
  OR: [CountryWhereInput!]
  NOT: [CountryWhereInput!]
}

input CountryWhereUniqueInput {
  id: Int
}

scalar DateTime

type Department {
  id: Int!
  created: DateTime!
  deleted: Boolean!
  location: String!
  managerId: Int!
  name: String!
  structureId: Int!
  updated: DateTime!
}

type DepartmentConnection {
  pageInfo: PageInfo!
  edges: [DepartmentEdge]!
  aggregate: AggregateDepartment!
}

input DepartmentCreateInput {
  id: Int
  deleted: Boolean!
  location: String!
  managerId: Int!
  name: String!
  structureId: Int!
  updated: DateTime!
}

type DepartmentEdge {
  node: Department!
  cursor: String!
}

enum DepartmentOrderByInput {
  id_ASC
  id_DESC
  created_ASC
  created_DESC
  deleted_ASC
  deleted_DESC
  location_ASC
  location_DESC
  managerId_ASC
  managerId_DESC
  name_ASC
  name_DESC
  structureId_ASC
  structureId_DESC
  updated_ASC
  updated_DESC
}

type DepartmentPreviousValues {
  id: Int!
  created: DateTime!
  deleted: Boolean!
  location: String!
  managerId: Int!
  name: String!
  structureId: Int!
  updated: DateTime!
}

type DepartmentSubscriptionPayload {
  mutation: MutationType!
  node: Department
  updatedFields: [String!]
  previousValues: DepartmentPreviousValues
}

input DepartmentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DepartmentWhereInput
  AND: [DepartmentSubscriptionWhereInput!]
  OR: [DepartmentSubscriptionWhereInput!]
  NOT: [DepartmentSubscriptionWhereInput!]
}

input DepartmentUpdateInput {
  deleted: Boolean
  location: String
  managerId: Int
  name: String
  structureId: Int
  updated: DateTime
}

input DepartmentUpdateManyMutationInput {
  deleted: Boolean
  location: String
  managerId: Int
  name: String
  structureId: Int
  updated: DateTime
}

input DepartmentWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  created: DateTime
  created_not: DateTime
  created_in: [DateTime!]
  created_not_in: [DateTime!]
  created_lt: DateTime
  created_lte: DateTime
  created_gt: DateTime
  created_gte: DateTime
  deleted: Boolean
  deleted_not: Boolean
  location: String
  location_not: String
  location_in: [String!]
  location_not_in: [String!]
  location_lt: String
  location_lte: String
  location_gt: String
  location_gte: String
  location_contains: String
  location_not_contains: String
  location_starts_with: String
  location_not_starts_with: String
  location_ends_with: String
  location_not_ends_with: String
  managerId: Int
  managerId_not: Int
  managerId_in: [Int!]
  managerId_not_in: [Int!]
  managerId_lt: Int
  managerId_lte: Int
  managerId_gt: Int
  managerId_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  structureId: Int
  structureId_not: Int
  structureId_in: [Int!]
  structureId_not_in: [Int!]
  structureId_lt: Int
  structureId_lte: Int
  structureId_gt: Int
  structureId_gte: Int
  updated: DateTime
  updated_not: DateTime
  updated_in: [DateTime!]
  updated_not_in: [DateTime!]
  updated_lt: DateTime
  updated_lte: DateTime
  updated_gt: DateTime
  updated_gte: DateTime
  AND: [DepartmentWhereInput!]
  OR: [DepartmentWhereInput!]
  NOT: [DepartmentWhereInput!]
}

input DepartmentWhereUniqueInput {
  id: Int
}

type DevisModele {
  id: Int!
  adresseId: Int
  created: DateTime!
  deleted: Boolean!
  modele: String
  name: String!
  structureId: Int!
  texteBas: String!
  updated: DateTime
}

type DevisModeleConnection {
  pageInfo: PageInfo!
  edges: [DevisModeleEdge]!
  aggregate: AggregateDevisModele!
}

input DevisModeleCreateInput {
  id: Int
  adresseId: Int
  created: DateTime!
  deleted: Boolean
  modele: String
  name: String!
  structureId: Int!
  texteBas: String!
  updated: DateTime
}

type DevisModeleEdge {
  node: DevisModele!
  cursor: String!
}

enum DevisModeleOrderByInput {
  id_ASC
  id_DESC
  adresseId_ASC
  adresseId_DESC
  created_ASC
  created_DESC
  deleted_ASC
  deleted_DESC
  modele_ASC
  modele_DESC
  name_ASC
  name_DESC
  structureId_ASC
  structureId_DESC
  texteBas_ASC
  texteBas_DESC
  updated_ASC
  updated_DESC
}

type DevisModelePreviousValues {
  id: Int!
  adresseId: Int
  created: DateTime!
  deleted: Boolean!
  modele: String
  name: String!
  structureId: Int!
  texteBas: String!
  updated: DateTime
}

type DevisModeleSubscriptionPayload {
  mutation: MutationType!
  node: DevisModele
  updatedFields: [String!]
  previousValues: DevisModelePreviousValues
}

input DevisModeleSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DevisModeleWhereInput
  AND: [DevisModeleSubscriptionWhereInput!]
  OR: [DevisModeleSubscriptionWhereInput!]
  NOT: [DevisModeleSubscriptionWhereInput!]
}

input DevisModeleUpdateInput {
  adresseId: Int
  created: DateTime
  deleted: Boolean
  modele: String
  name: String
  structureId: Int
  texteBas: String
  updated: DateTime
}

input DevisModeleUpdateManyMutationInput {
  adresseId: Int
  created: DateTime
  deleted: Boolean
  modele: String
  name: String
  structureId: Int
  texteBas: String
  updated: DateTime
}

input DevisModeleWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  adresseId: Int
  adresseId_not: Int
  adresseId_in: [Int!]
  adresseId_not_in: [Int!]
  adresseId_lt: Int
  adresseId_lte: Int
  adresseId_gt: Int
  adresseId_gte: Int
  created: DateTime
  created_not: DateTime
  created_in: [DateTime!]
  created_not_in: [DateTime!]
  created_lt: DateTime
  created_lte: DateTime
  created_gt: DateTime
  created_gte: DateTime
  deleted: Boolean
  deleted_not: Boolean
  modele: String
  modele_not: String
  modele_in: [String!]
  modele_not_in: [String!]
  modele_lt: String
  modele_lte: String
  modele_gt: String
  modele_gte: String
  modele_contains: String
  modele_not_contains: String
  modele_starts_with: String
  modele_not_starts_with: String
  modele_ends_with: String
  modele_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  structureId: Int
  structureId_not: Int
  structureId_in: [Int!]
  structureId_not_in: [Int!]
  structureId_lt: Int
  structureId_lte: Int
  structureId_gt: Int
  structureId_gte: Int
  texteBas: String
  texteBas_not: String
  texteBas_in: [String!]
  texteBas_not_in: [String!]
  texteBas_lt: String
  texteBas_lte: String
  texteBas_gt: String
  texteBas_gte: String
  texteBas_contains: String
  texteBas_not_contains: String
  texteBas_starts_with: String
  texteBas_not_starts_with: String
  texteBas_ends_with: String
  texteBas_not_ends_with: String
  updated: DateTime
  updated_not: DateTime
  updated_in: [DateTime!]
  updated_not_in: [DateTime!]
  updated_lt: DateTime
  updated_lte: DateTime
  updated_gt: DateTime
  updated_gte: DateTime
  AND: [DevisModeleWhereInput!]
  OR: [DevisModeleWhereInput!]
  NOT: [DevisModeleWhereInput!]
}

input DevisModeleWhereUniqueInput {
  id: Int
}

type Document {
  id: Int!
  commentaire: String
  created: DateTime!
  dateEmission: DateTime
  deleted: Boolean!
  documentTypeId: Int!
  entityId: Int!
  file: String!
  insertedId: Int
  name: String!
  public: Boolean!
  structureId: Int!
  updated: DateTime
  verEdition: Boolean!
}

type DocumentConnection {
  pageInfo: PageInfo!
  edges: [DocumentEdge]!
  aggregate: AggregateDocument!
}

input DocumentCreateInput {
  id: Int
  commentaire: String
  created: DateTime!
  dateEmission: DateTime
  deleted: Boolean
  documentTypeId: Int
  entityId: Int
  file: String!
  insertedId: Int
  name: String!
  public: Boolean
  structureId: Int!
  updated: DateTime
  verEdition: Boolean
}

type DocumentEdge {
  node: Document!
  cursor: String!
}

enum DocumentOrderByInput {
  id_ASC
  id_DESC
  commentaire_ASC
  commentaire_DESC
  created_ASC
  created_DESC
  dateEmission_ASC
  dateEmission_DESC
  deleted_ASC
  deleted_DESC
  documentTypeId_ASC
  documentTypeId_DESC
  entityId_ASC
  entityId_DESC
  file_ASC
  file_DESC
  insertedId_ASC
  insertedId_DESC
  name_ASC
  name_DESC
  public_ASC
  public_DESC
  structureId_ASC
  structureId_DESC
  updated_ASC
  updated_DESC
  verEdition_ASC
  verEdition_DESC
}

type DocumentPreviousValues {
  id: Int!
  commentaire: String
  created: DateTime!
  dateEmission: DateTime
  deleted: Boolean!
  documentTypeId: Int!
  entityId: Int!
  file: String!
  insertedId: Int
  name: String!
  public: Boolean!
  structureId: Int!
  updated: DateTime
  verEdition: Boolean!
}

type DocumentSubscriptionPayload {
  mutation: MutationType!
  node: Document
  updatedFields: [String!]
  previousValues: DocumentPreviousValues
}

input DocumentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DocumentWhereInput
  AND: [DocumentSubscriptionWhereInput!]
  OR: [DocumentSubscriptionWhereInput!]
  NOT: [DocumentSubscriptionWhereInput!]
}

type DocumentType {
  id: Int!
  title: String!
}

type DocumentTypeConnection {
  pageInfo: PageInfo!
  edges: [DocumentTypeEdge]!
  aggregate: AggregateDocumentType!
}

input DocumentTypeCreateInput {
  id: Int
  title: String!
}

type DocumentTypeEdge {
  node: DocumentType!
  cursor: String!
}

enum DocumentTypeOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
}

type DocumentTypePreviousValues {
  id: Int!
  title: String!
}

type DocumentTypeSubscriptionPayload {
  mutation: MutationType!
  node: DocumentType
  updatedFields: [String!]
  previousValues: DocumentTypePreviousValues
}

input DocumentTypeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DocumentTypeWhereInput
  AND: [DocumentTypeSubscriptionWhereInput!]
  OR: [DocumentTypeSubscriptionWhereInput!]
  NOT: [DocumentTypeSubscriptionWhereInput!]
}

input DocumentTypeUpdateInput {
  title: String
}

input DocumentTypeUpdateManyMutationInput {
  title: String
}

input DocumentTypeWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  AND: [DocumentTypeWhereInput!]
  OR: [DocumentTypeWhereInput!]
  NOT: [DocumentTypeWhereInput!]
}

input DocumentTypeWhereUniqueInput {
  id: Int
}

input DocumentUpdateInput {
  commentaire: String
  created: DateTime
  dateEmission: DateTime
  deleted: Boolean
  documentTypeId: Int
  entityId: Int
  file: String
  insertedId: Int
  name: String
  public: Boolean
  structureId: Int
  updated: DateTime
  verEdition: Boolean
}

input DocumentUpdateManyMutationInput {
  commentaire: String
  created: DateTime
  dateEmission: DateTime
  deleted: Boolean
  documentTypeId: Int
  entityId: Int
  file: String
  insertedId: Int
  name: String
  public: Boolean
  structureId: Int
  updated: DateTime
  verEdition: Boolean
}

input DocumentWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  commentaire: String
  commentaire_not: String
  commentaire_in: [String!]
  commentaire_not_in: [String!]
  commentaire_lt: String
  commentaire_lte: String
  commentaire_gt: String
  commentaire_gte: String
  commentaire_contains: String
  commentaire_not_contains: String
  commentaire_starts_with: String
  commentaire_not_starts_with: String
  commentaire_ends_with: String
  commentaire_not_ends_with: String
  created: DateTime
  created_not: DateTime
  created_in: [DateTime!]
  created_not_in: [DateTime!]
  created_lt: DateTime
  created_lte: DateTime
  created_gt: DateTime
  created_gte: DateTime
  dateEmission: DateTime
  dateEmission_not: DateTime
  dateEmission_in: [DateTime!]
  dateEmission_not_in: [DateTime!]
  dateEmission_lt: DateTime
  dateEmission_lte: DateTime
  dateEmission_gt: DateTime
  dateEmission_gte: DateTime
  deleted: Boolean
  deleted_not: Boolean
  documentTypeId: Int
  documentTypeId_not: Int
  documentTypeId_in: [Int!]
  documentTypeId_not_in: [Int!]
  documentTypeId_lt: Int
  documentTypeId_lte: Int
  documentTypeId_gt: Int
  documentTypeId_gte: Int
  entityId: Int
  entityId_not: Int
  entityId_in: [Int!]
  entityId_not_in: [Int!]
  entityId_lt: Int
  entityId_lte: Int
  entityId_gt: Int
  entityId_gte: Int
  file: String
  file_not: String
  file_in: [String!]
  file_not_in: [String!]
  file_lt: String
  file_lte: String
  file_gt: String
  file_gte: String
  file_contains: String
  file_not_contains: String
  file_starts_with: String
  file_not_starts_with: String
  file_ends_with: String
  file_not_ends_with: String
  insertedId: Int
  insertedId_not: Int
  insertedId_in: [Int!]
  insertedId_not_in: [Int!]
  insertedId_lt: Int
  insertedId_lte: Int
  insertedId_gt: Int
  insertedId_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  public: Boolean
  public_not: Boolean
  structureId: Int
  structureId_not: Int
  structureId_in: [Int!]
  structureId_not_in: [Int!]
  structureId_lt: Int
  structureId_lte: Int
  structureId_gt: Int
  structureId_gte: Int
  updated: DateTime
  updated_not: DateTime
  updated_in: [DateTime!]
  updated_not_in: [DateTime!]
  updated_lt: DateTime
  updated_lte: DateTime
  updated_gt: DateTime
  updated_gte: DateTime
  verEdition: Boolean
  verEdition_not: Boolean
  AND: [DocumentWhereInput!]
  OR: [DocumentWhereInput!]
  NOT: [DocumentWhereInput!]
}

input DocumentWhereUniqueInput {
  id: Int
}

type EmpInfo {
  id: Int!
  compteBancaire: String
  created: DateTime
  deleted: Boolean
  nbreEnfants: Int
  numCimr: String
  numCnss: String
  numMutuelle: String
  numPasseport: String
  situationFamiliale: Int
  updated: DateTime
}

type EmpInfoConnection {
  pageInfo: PageInfo!
  edges: [EmpInfoEdge]!
  aggregate: AggregateEmpInfo!
}

input EmpInfoCreateInput {
  id: Int
  compteBancaire: String
  deleted: Boolean
  nbreEnfants: Int
  numCimr: String
  numCnss: String
  numMutuelle: String
  numPasseport: String
  situationFamiliale: Int
}

type EmpInfoEdge {
  node: EmpInfo!
  cursor: String!
}

enum EmpInfoOrderByInput {
  id_ASC
  id_DESC
  compteBancaire_ASC
  compteBancaire_DESC
  created_ASC
  created_DESC
  deleted_ASC
  deleted_DESC
  nbreEnfants_ASC
  nbreEnfants_DESC
  numCimr_ASC
  numCimr_DESC
  numCnss_ASC
  numCnss_DESC
  numMutuelle_ASC
  numMutuelle_DESC
  numPasseport_ASC
  numPasseport_DESC
  situationFamiliale_ASC
  situationFamiliale_DESC
  updated_ASC
  updated_DESC
}

type EmpInfoPreviousValues {
  id: Int!
  compteBancaire: String
  created: DateTime
  deleted: Boolean
  nbreEnfants: Int
  numCimr: String
  numCnss: String
  numMutuelle: String
  numPasseport: String
  situationFamiliale: Int
  updated: DateTime
}

type EmpInfoSubscriptionPayload {
  mutation: MutationType!
  node: EmpInfo
  updatedFields: [String!]
  previousValues: EmpInfoPreviousValues
}

input EmpInfoSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: EmpInfoWhereInput
  AND: [EmpInfoSubscriptionWhereInput!]
  OR: [EmpInfoSubscriptionWhereInput!]
  NOT: [EmpInfoSubscriptionWhereInput!]
}

input EmpInfoUpdateInput {
  compteBancaire: String
  deleted: Boolean
  nbreEnfants: Int
  numCimr: String
  numCnss: String
  numMutuelle: String
  numPasseport: String
  situationFamiliale: Int
}

input EmpInfoUpdateManyMutationInput {
  compteBancaire: String
  deleted: Boolean
  nbreEnfants: Int
  numCimr: String
  numCnss: String
  numMutuelle: String
  numPasseport: String
  situationFamiliale: Int
}

input EmpInfoWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  compteBancaire: String
  compteBancaire_not: String
  compteBancaire_in: [String!]
  compteBancaire_not_in: [String!]
  compteBancaire_lt: String
  compteBancaire_lte: String
  compteBancaire_gt: String
  compteBancaire_gte: String
  compteBancaire_contains: String
  compteBancaire_not_contains: String
  compteBancaire_starts_with: String
  compteBancaire_not_starts_with: String
  compteBancaire_ends_with: String
  compteBancaire_not_ends_with: String
  created: DateTime
  created_not: DateTime
  created_in: [DateTime!]
  created_not_in: [DateTime!]
  created_lt: DateTime
  created_lte: DateTime
  created_gt: DateTime
  created_gte: DateTime
  deleted: Boolean
  deleted_not: Boolean
  nbreEnfants: Int
  nbreEnfants_not: Int
  nbreEnfants_in: [Int!]
  nbreEnfants_not_in: [Int!]
  nbreEnfants_lt: Int
  nbreEnfants_lte: Int
  nbreEnfants_gt: Int
  nbreEnfants_gte: Int
  numCimr: String
  numCimr_not: String
  numCimr_in: [String!]
  numCimr_not_in: [String!]
  numCimr_lt: String
  numCimr_lte: String
  numCimr_gt: String
  numCimr_gte: String
  numCimr_contains: String
  numCimr_not_contains: String
  numCimr_starts_with: String
  numCimr_not_starts_with: String
  numCimr_ends_with: String
  numCimr_not_ends_with: String
  numCnss: String
  numCnss_not: String
  numCnss_in: [String!]
  numCnss_not_in: [String!]
  numCnss_lt: String
  numCnss_lte: String
  numCnss_gt: String
  numCnss_gte: String
  numCnss_contains: String
  numCnss_not_contains: String
  numCnss_starts_with: String
  numCnss_not_starts_with: String
  numCnss_ends_with: String
  numCnss_not_ends_with: String
  numMutuelle: String
  numMutuelle_not: String
  numMutuelle_in: [String!]
  numMutuelle_not_in: [String!]
  numMutuelle_lt: String
  numMutuelle_lte: String
  numMutuelle_gt: String
  numMutuelle_gte: String
  numMutuelle_contains: String
  numMutuelle_not_contains: String
  numMutuelle_starts_with: String
  numMutuelle_not_starts_with: String
  numMutuelle_ends_with: String
  numMutuelle_not_ends_with: String
  numPasseport: String
  numPasseport_not: String
  numPasseport_in: [String!]
  numPasseport_not_in: [String!]
  numPasseport_lt: String
  numPasseport_lte: String
  numPasseport_gt: String
  numPasseport_gte: String
  numPasseport_contains: String
  numPasseport_not_contains: String
  numPasseport_starts_with: String
  numPasseport_not_starts_with: String
  numPasseport_ends_with: String
  numPasseport_not_ends_with: String
  situationFamiliale: Int
  situationFamiliale_not: Int
  situationFamiliale_in: [Int!]
  situationFamiliale_not_in: [Int!]
  situationFamiliale_lt: Int
  situationFamiliale_lte: Int
  situationFamiliale_gt: Int
  situationFamiliale_gte: Int
  updated: DateTime
  updated_not: DateTime
  updated_in: [DateTime!]
  updated_not_in: [DateTime!]
  updated_lt: DateTime
  updated_lte: DateTime
  updated_gt: DateTime
  updated_gte: DateTime
  AND: [EmpInfoWhereInput!]
  OR: [EmpInfoWhereInput!]
  NOT: [EmpInfoWhereInput!]
}

input EmpInfoWhereUniqueInput {
  id: Int
}

type Employe {
  id: Int!
  email: String
  adresseId: Int
  code: String
  created: DateTime!
  deleted: Boolean
  departmentId: Int
  empInfoId: Int
  firstname: String!
  gender: Int
  hireDate: DateTime
  jobId: Int
  lastname: String!
  managerId: Int
  phone1: String
  phone2: String
  salary: Float
  structureId: Int
  type: Boolean
  updated: DateTime
}

type EmployeConnection {
  pageInfo: PageInfo!
  edges: [EmployeEdge]!
  aggregate: AggregateEmploye!
}

input EmployeCreateInput {
  id: Int
  email: String
  adresseId: Int
  code: String
  deleted: Boolean
  departmentId: Int
  empInfoId: Int
  firstname: String!
  gender: Int
  hireDate: DateTime
  jobId: Int
  lastname: String!
  managerId: Int
  phone1: String
  phone2: String
  salary: Float
  structureId: Int
  type: Boolean
  updated: DateTime
}

type EmployeEdge {
  node: Employe!
  cursor: String!
}

enum EmployeOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  adresseId_ASC
  adresseId_DESC
  code_ASC
  code_DESC
  created_ASC
  created_DESC
  deleted_ASC
  deleted_DESC
  departmentId_ASC
  departmentId_DESC
  empInfoId_ASC
  empInfoId_DESC
  firstname_ASC
  firstname_DESC
  gender_ASC
  gender_DESC
  hireDate_ASC
  hireDate_DESC
  jobId_ASC
  jobId_DESC
  lastname_ASC
  lastname_DESC
  managerId_ASC
  managerId_DESC
  phone1_ASC
  phone1_DESC
  phone2_ASC
  phone2_DESC
  salary_ASC
  salary_DESC
  structureId_ASC
  structureId_DESC
  type_ASC
  type_DESC
  updated_ASC
  updated_DESC
}

type EmployePreviousValues {
  id: Int!
  email: String
  adresseId: Int
  code: String
  created: DateTime!
  deleted: Boolean
  departmentId: Int
  empInfoId: Int
  firstname: String!
  gender: Int
  hireDate: DateTime
  jobId: Int
  lastname: String!
  managerId: Int
  phone1: String
  phone2: String
  salary: Float
  structureId: Int
  type: Boolean
  updated: DateTime
}

type EmployeSubscriptionPayload {
  mutation: MutationType!
  node: Employe
  updatedFields: [String!]
  previousValues: EmployePreviousValues
}

input EmployeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: EmployeWhereInput
  AND: [EmployeSubscriptionWhereInput!]
  OR: [EmployeSubscriptionWhereInput!]
  NOT: [EmployeSubscriptionWhereInput!]
}

input EmployeUpdateInput {
  email: String
  adresseId: Int
  code: String
  deleted: Boolean
  departmentId: Int
  empInfoId: Int
  firstname: String
  gender: Int
  hireDate: DateTime
  jobId: Int
  lastname: String
  managerId: Int
  phone1: String
  phone2: String
  salary: Float
  structureId: Int
  type: Boolean
  updated: DateTime
}

input EmployeUpdateManyMutationInput {
  email: String
  adresseId: Int
  code: String
  deleted: Boolean
  departmentId: Int
  empInfoId: Int
  firstname: String
  gender: Int
  hireDate: DateTime
  jobId: Int
  lastname: String
  managerId: Int
  phone1: String
  phone2: String
  salary: Float
  structureId: Int
  type: Boolean
  updated: DateTime
}

input EmployeWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  adresseId: Int
  adresseId_not: Int
  adresseId_in: [Int!]
  adresseId_not_in: [Int!]
  adresseId_lt: Int
  adresseId_lte: Int
  adresseId_gt: Int
  adresseId_gte: Int
  code: String
  code_not: String
  code_in: [String!]
  code_not_in: [String!]
  code_lt: String
  code_lte: String
  code_gt: String
  code_gte: String
  code_contains: String
  code_not_contains: String
  code_starts_with: String
  code_not_starts_with: String
  code_ends_with: String
  code_not_ends_with: String
  created: DateTime
  created_not: DateTime
  created_in: [DateTime!]
  created_not_in: [DateTime!]
  created_lt: DateTime
  created_lte: DateTime
  created_gt: DateTime
  created_gte: DateTime
  deleted: Boolean
  deleted_not: Boolean
  departmentId: Int
  departmentId_not: Int
  departmentId_in: [Int!]
  departmentId_not_in: [Int!]
  departmentId_lt: Int
  departmentId_lte: Int
  departmentId_gt: Int
  departmentId_gte: Int
  empInfoId: Int
  empInfoId_not: Int
  empInfoId_in: [Int!]
  empInfoId_not_in: [Int!]
  empInfoId_lt: Int
  empInfoId_lte: Int
  empInfoId_gt: Int
  empInfoId_gte: Int
  firstname: String
  firstname_not: String
  firstname_in: [String!]
  firstname_not_in: [String!]
  firstname_lt: String
  firstname_lte: String
  firstname_gt: String
  firstname_gte: String
  firstname_contains: String
  firstname_not_contains: String
  firstname_starts_with: String
  firstname_not_starts_with: String
  firstname_ends_with: String
  firstname_not_ends_with: String
  gender: Int
  gender_not: Int
  gender_in: [Int!]
  gender_not_in: [Int!]
  gender_lt: Int
  gender_lte: Int
  gender_gt: Int
  gender_gte: Int
  hireDate: DateTime
  hireDate_not: DateTime
  hireDate_in: [DateTime!]
  hireDate_not_in: [DateTime!]
  hireDate_lt: DateTime
  hireDate_lte: DateTime
  hireDate_gt: DateTime
  hireDate_gte: DateTime
  jobId: Int
  jobId_not: Int
  jobId_in: [Int!]
  jobId_not_in: [Int!]
  jobId_lt: Int
  jobId_lte: Int
  jobId_gt: Int
  jobId_gte: Int
  lastname: String
  lastname_not: String
  lastname_in: [String!]
  lastname_not_in: [String!]
  lastname_lt: String
  lastname_lte: String
  lastname_gt: String
  lastname_gte: String
  lastname_contains: String
  lastname_not_contains: String
  lastname_starts_with: String
  lastname_not_starts_with: String
  lastname_ends_with: String
  lastname_not_ends_with: String
  managerId: Int
  managerId_not: Int
  managerId_in: [Int!]
  managerId_not_in: [Int!]
  managerId_lt: Int
  managerId_lte: Int
  managerId_gt: Int
  managerId_gte: Int
  phone1: String
  phone1_not: String
  phone1_in: [String!]
  phone1_not_in: [String!]
  phone1_lt: String
  phone1_lte: String
  phone1_gt: String
  phone1_gte: String
  phone1_contains: String
  phone1_not_contains: String
  phone1_starts_with: String
  phone1_not_starts_with: String
  phone1_ends_with: String
  phone1_not_ends_with: String
  phone2: String
  phone2_not: String
  phone2_in: [String!]
  phone2_not_in: [String!]
  phone2_lt: String
  phone2_lte: String
  phone2_gt: String
  phone2_gte: String
  phone2_contains: String
  phone2_not_contains: String
  phone2_starts_with: String
  phone2_not_starts_with: String
  phone2_ends_with: String
  phone2_not_ends_with: String
  salary: Float
  salary_not: Float
  salary_in: [Float!]
  salary_not_in: [Float!]
  salary_lt: Float
  salary_lte: Float
  salary_gt: Float
  salary_gte: Float
  structureId: Int
  structureId_not: Int
  structureId_in: [Int!]
  structureId_not_in: [Int!]
  structureId_lt: Int
  structureId_lte: Int
  structureId_gt: Int
  structureId_gte: Int
  type: Boolean
  type_not: Boolean
  updated: DateTime
  updated_not: DateTime
  updated_in: [DateTime!]
  updated_not_in: [DateTime!]
  updated_lt: DateTime
  updated_lte: DateTime
  updated_gt: DateTime
  updated_gte: DateTime
  AND: [EmployeWhereInput!]
  OR: [EmployeWhereInput!]
  NOT: [EmployeWhereInput!]
}

input EmployeWhereUniqueInput {
  id: Int
}

type Entity {
  id: Int!
  addressId: Int!
  created: DateTime!
  deleted: Boolean!
  name: String!
  seat: String!
  structureId: Int!
  updated: DateTime
}

type EntityConnection {
  pageInfo: PageInfo!
  edges: [EntityEdge]!
  aggregate: AggregateEntity!
}

input EntityCreateInput {
  id: Int
  addressId: Int!
  deleted: Boolean
  name: String!
  seat: String!
  structureId: Int!
}

type EntityEdge {
  node: Entity!
  cursor: String!
}

enum EntityOrderByInput {
  id_ASC
  id_DESC
  addressId_ASC
  addressId_DESC
  created_ASC
  created_DESC
  deleted_ASC
  deleted_DESC
  name_ASC
  name_DESC
  seat_ASC
  seat_DESC
  structureId_ASC
  structureId_DESC
  updated_ASC
  updated_DESC
}

type EntityPreviousValues {
  id: Int!
  addressId: Int!
  created: DateTime!
  deleted: Boolean!
  name: String!
  seat: String!
  structureId: Int!
  updated: DateTime
}

type EntitySubscriptionPayload {
  mutation: MutationType!
  node: Entity
  updatedFields: [String!]
  previousValues: EntityPreviousValues
}

input EntitySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: EntityWhereInput
  AND: [EntitySubscriptionWhereInput!]
  OR: [EntitySubscriptionWhereInput!]
  NOT: [EntitySubscriptionWhereInput!]
}

input EntityUpdateInput {
  addressId: Int
  deleted: Boolean
  name: String
  seat: String
  structureId: Int
}

input EntityUpdateManyMutationInput {
  addressId: Int
  deleted: Boolean
  name: String
  seat: String
  structureId: Int
}

input EntityWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  addressId: Int
  addressId_not: Int
  addressId_in: [Int!]
  addressId_not_in: [Int!]
  addressId_lt: Int
  addressId_lte: Int
  addressId_gt: Int
  addressId_gte: Int
  created: DateTime
  created_not: DateTime
  created_in: [DateTime!]
  created_not_in: [DateTime!]
  created_lt: DateTime
  created_lte: DateTime
  created_gt: DateTime
  created_gte: DateTime
  deleted: Boolean
  deleted_not: Boolean
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  seat: String
  seat_not: String
  seat_in: [String!]
  seat_not_in: [String!]
  seat_lt: String
  seat_lte: String
  seat_gt: String
  seat_gte: String
  seat_contains: String
  seat_not_contains: String
  seat_starts_with: String
  seat_not_starts_with: String
  seat_ends_with: String
  seat_not_ends_with: String
  structureId: Int
  structureId_not: Int
  structureId_in: [Int!]
  structureId_not_in: [Int!]
  structureId_lt: Int
  structureId_lte: Int
  structureId_gt: Int
  structureId_gte: Int
  updated: DateTime
  updated_not: DateTime
  updated_in: [DateTime!]
  updated_not_in: [DateTime!]
  updated_lt: DateTime
  updated_lte: DateTime
  updated_gt: DateTime
  updated_gte: DateTime
  AND: [EntityWhereInput!]
  OR: [EntityWhereInput!]
  NOT: [EntityWhereInput!]
}

input EntityWhereUniqueInput {
  id: Int
}

type File {
  id: Int!
  messageId: Int!
  nom: String!
}

type FileConnection {
  pageInfo: PageInfo!
  edges: [FileEdge]!
  aggregate: AggregateFile!
}

input FileCreateInput {
  id: Int
  messageId: Int!
  nom: String!
}

type FileEdge {
  node: File!
  cursor: String!
}

enum FileOrderByInput {
  id_ASC
  id_DESC
  messageId_ASC
  messageId_DESC
  nom_ASC
  nom_DESC
}

type FilePreviousValues {
  id: Int!
  messageId: Int!
  nom: String!
}

type FileSubscriptionPayload {
  mutation: MutationType!
  node: File
  updatedFields: [String!]
  previousValues: FilePreviousValues
}

input FileSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FileWhereInput
  AND: [FileSubscriptionWhereInput!]
  OR: [FileSubscriptionWhereInput!]
  NOT: [FileSubscriptionWhereInput!]
}

input FileUpdateInput {
  messageId: Int
  nom: String
}

input FileUpdateManyMutationInput {
  messageId: Int
  nom: String
}

input FileWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  messageId: Int
  messageId_not: Int
  messageId_in: [Int!]
  messageId_not_in: [Int!]
  messageId_lt: Int
  messageId_lte: Int
  messageId_gt: Int
  messageId_gte: Int
  nom: String
  nom_not: String
  nom_in: [String!]
  nom_not_in: [String!]
  nom_lt: String
  nom_lte: String
  nom_gt: String
  nom_gte: String
  nom_contains: String
  nom_not_contains: String
  nom_starts_with: String
  nom_not_starts_with: String
  nom_ends_with: String
  nom_not_ends_with: String
  AND: [FileWhereInput!]
  OR: [FileWhereInput!]
  NOT: [FileWhereInput!]
}

input FileWhereUniqueInput {
  id: Int
}

type Job {
  id: Int!
  created: DateTime!
  deleted: Boolean
  description: String!
  keyword: String!
  maxSalary: Float!
  minSalary: Float!
  title: String!
  updated: DateTime!
}

type JobConnection {
  pageInfo: PageInfo!
  edges: [JobEdge]!
  aggregate: AggregateJob!
}

input JobCreateInput {
  id: Int
  deleted: Boolean
  description: String!
  keyword: String!
  maxSalary: Float!
  minSalary: Float!
  title: String!
}

type JobEdge {
  node: Job!
  cursor: String!
}

enum JobOrderByInput {
  id_ASC
  id_DESC
  created_ASC
  created_DESC
  deleted_ASC
  deleted_DESC
  description_ASC
  description_DESC
  keyword_ASC
  keyword_DESC
  maxSalary_ASC
  maxSalary_DESC
  minSalary_ASC
  minSalary_DESC
  title_ASC
  title_DESC
  updated_ASC
  updated_DESC
}

type JobPreviousValues {
  id: Int!
  created: DateTime!
  deleted: Boolean
  description: String!
  keyword: String!
  maxSalary: Float!
  minSalary: Float!
  title: String!
  updated: DateTime!
}

type JobSubscriptionPayload {
  mutation: MutationType!
  node: Job
  updatedFields: [String!]
  previousValues: JobPreviousValues
}

input JobSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: JobWhereInput
  AND: [JobSubscriptionWhereInput!]
  OR: [JobSubscriptionWhereInput!]
  NOT: [JobSubscriptionWhereInput!]
}

input JobUpdateInput {
  deleted: Boolean
  description: String
  keyword: String
  maxSalary: Float
  minSalary: Float
  title: String
}

input JobUpdateManyMutationInput {
  deleted: Boolean
  description: String
  keyword: String
  maxSalary: Float
  minSalary: Float
  title: String
}

input JobWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  created: DateTime
  created_not: DateTime
  created_in: [DateTime!]
  created_not_in: [DateTime!]
  created_lt: DateTime
  created_lte: DateTime
  created_gt: DateTime
  created_gte: DateTime
  deleted: Boolean
  deleted_not: Boolean
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  keyword: String
  keyword_not: String
  keyword_in: [String!]
  keyword_not_in: [String!]
  keyword_lt: String
  keyword_lte: String
  keyword_gt: String
  keyword_gte: String
  keyword_contains: String
  keyword_not_contains: String
  keyword_starts_with: String
  keyword_not_starts_with: String
  keyword_ends_with: String
  keyword_not_ends_with: String
  maxSalary: Float
  maxSalary_not: Float
  maxSalary_in: [Float!]
  maxSalary_not_in: [Float!]
  maxSalary_lt: Float
  maxSalary_lte: Float
  maxSalary_gt: Float
  maxSalary_gte: Float
  minSalary: Float
  minSalary_not: Float
  minSalary_in: [Float!]
  minSalary_not_in: [Float!]
  minSalary_lt: Float
  minSalary_lte: Float
  minSalary_gt: Float
  minSalary_gte: Float
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  updated: DateTime
  updated_not: DateTime
  updated_in: [DateTime!]
  updated_not_in: [DateTime!]
  updated_lt: DateTime
  updated_lte: DateTime
  updated_gt: DateTime
  updated_gte: DateTime
  AND: [JobWhereInput!]
  OR: [JobWhereInput!]
  NOT: [JobWhereInput!]
}

input JobWhereUniqueInput {
  id: Int
}

type LegalType {
  id: Int!
  code: String
  created: DateTime!
  name: String!
}

type LegalTypeConnection {
  pageInfo: PageInfo!
  edges: [LegalTypeEdge]!
  aggregate: AggregateLegalType!
}

input LegalTypeCreateInput {
  id: Int
  code: String
  name: String!
}

type LegalTypeEdge {
  node: LegalType!
  cursor: String!
}

enum LegalTypeOrderByInput {
  id_ASC
  id_DESC
  code_ASC
  code_DESC
  created_ASC
  created_DESC
  name_ASC
  name_DESC
}

type LegalTypePreviousValues {
  id: Int!
  code: String
  created: DateTime!
  name: String!
}

type LegalTypeSubscriptionPayload {
  mutation: MutationType!
  node: LegalType
  updatedFields: [String!]
  previousValues: LegalTypePreviousValues
}

input LegalTypeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LegalTypeWhereInput
  AND: [LegalTypeSubscriptionWhereInput!]
  OR: [LegalTypeSubscriptionWhereInput!]
  NOT: [LegalTypeSubscriptionWhereInput!]
}

input LegalTypeUpdateInput {
  code: String
  name: String
}

input LegalTypeUpdateManyMutationInput {
  code: String
  name: String
}

input LegalTypeWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  code: String
  code_not: String
  code_in: [String!]
  code_not_in: [String!]
  code_lt: String
  code_lte: String
  code_gt: String
  code_gte: String
  code_contains: String
  code_not_contains: String
  code_starts_with: String
  code_not_starts_with: String
  code_ends_with: String
  code_not_ends_with: String
  created: DateTime
  created_not: DateTime
  created_in: [DateTime!]
  created_not_in: [DateTime!]
  created_lt: DateTime
  created_lte: DateTime
  created_gt: DateTime
  created_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [LegalTypeWhereInput!]
  OR: [LegalTypeWhereInput!]
  NOT: [LegalTypeWhereInput!]
}

input LegalTypeWhereUniqueInput {
  id: Int
}

scalar Long

type Maction {
  id: Int!
  date: DateTime!
  deleted: Boolean!
  description: String
  effectuePar: String!
  memberId: Int!
  statut: Int!
  titre: String!
}

type MactionConnection {
  pageInfo: PageInfo!
  edges: [MactionEdge]!
  aggregate: AggregateMaction!
}

input MactionCreateInput {
  id: Int
  deleted: Boolean
  description: String
  effectuePar: String!
  memberId: Int!
  statut: Int
  titre: String!
}

type MactionEdge {
  node: Maction!
  cursor: String!
}

enum MactionOrderByInput {
  id_ASC
  id_DESC
  date_ASC
  date_DESC
  deleted_ASC
  deleted_DESC
  description_ASC
  description_DESC
  effectuePar_ASC
  effectuePar_DESC
  memberId_ASC
  memberId_DESC
  statut_ASC
  statut_DESC
  titre_ASC
  titre_DESC
}

type MactionPreviousValues {
  id: Int!
  date: DateTime!
  deleted: Boolean!
  description: String
  effectuePar: String!
  memberId: Int!
  statut: Int!
  titre: String!
}

type MactionSubscriptionPayload {
  mutation: MutationType!
  node: Maction
  updatedFields: [String!]
  previousValues: MactionPreviousValues
}

input MactionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MactionWhereInput
  AND: [MactionSubscriptionWhereInput!]
  OR: [MactionSubscriptionWhereInput!]
  NOT: [MactionSubscriptionWhereInput!]
}

input MactionUpdateInput {
  deleted: Boolean
  description: String
  effectuePar: String
  memberId: Int
  statut: Int
  titre: String
}

input MactionUpdateManyMutationInput {
  deleted: Boolean
  description: String
  effectuePar: String
  memberId: Int
  statut: Int
  titre: String
}

input MactionWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  deleted: Boolean
  deleted_not: Boolean
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  effectuePar: String
  effectuePar_not: String
  effectuePar_in: [String!]
  effectuePar_not_in: [String!]
  effectuePar_lt: String
  effectuePar_lte: String
  effectuePar_gt: String
  effectuePar_gte: String
  effectuePar_contains: String
  effectuePar_not_contains: String
  effectuePar_starts_with: String
  effectuePar_not_starts_with: String
  effectuePar_ends_with: String
  effectuePar_not_ends_with: String
  memberId: Int
  memberId_not: Int
  memberId_in: [Int!]
  memberId_not_in: [Int!]
  memberId_lt: Int
  memberId_lte: Int
  memberId_gt: Int
  memberId_gte: Int
  statut: Int
  statut_not: Int
  statut_in: [Int!]
  statut_not_in: [Int!]
  statut_lt: Int
  statut_lte: Int
  statut_gt: Int
  statut_gte: Int
  titre: String
  titre_not: String
  titre_in: [String!]
  titre_not_in: [String!]
  titre_lt: String
  titre_lte: String
  titre_gt: String
  titre_gte: String
  titre_contains: String
  titre_not_contains: String
  titre_starts_with: String
  titre_not_starts_with: String
  titre_ends_with: String
  titre_not_ends_with: String
  AND: [MactionWhereInput!]
  OR: [MactionWhereInput!]
  NOT: [MactionWhereInput!]
}

input MactionWhereUniqueInput {
  id: Int
}

type Movement {
  id: Int!
  created: DateTime!
  date: DateTime
  deleted: Boolean!
  designation: String!
  documentId: Int
  htTotal: Float
  insertedId: Int
  price: Float
  quantite: String
  structureId: Int!
  ttcTotal: Float!
  tvaId: Int
  type: Boolean!
}

type MovementConnection {
  pageInfo: PageInfo!
  edges: [MovementEdge]!
  aggregate: AggregateMovement!
}

input MovementCreateInput {
  id: Int
  date: DateTime
  deleted: Boolean
  designation: String!
  documentId: Int
  htTotal: Float
  insertedId: Int
  price: Float
  quantite: String
  structureId: Int!
  ttcTotal: Float!
  tvaId: Int
  type: Boolean
}

type MovementEdge {
  node: Movement!
  cursor: String!
}

enum MovementOrderByInput {
  id_ASC
  id_DESC
  created_ASC
  created_DESC
  date_ASC
  date_DESC
  deleted_ASC
  deleted_DESC
  designation_ASC
  designation_DESC
  documentId_ASC
  documentId_DESC
  htTotal_ASC
  htTotal_DESC
  insertedId_ASC
  insertedId_DESC
  price_ASC
  price_DESC
  quantite_ASC
  quantite_DESC
  structureId_ASC
  structureId_DESC
  ttcTotal_ASC
  ttcTotal_DESC
  tvaId_ASC
  tvaId_DESC
  type_ASC
  type_DESC
}

type MovementPreviousValues {
  id: Int!
  created: DateTime!
  date: DateTime
  deleted: Boolean!
  designation: String!
  documentId: Int
  htTotal: Float
  insertedId: Int
  price: Float
  quantite: String
  structureId: Int!
  ttcTotal: Float!
  tvaId: Int
  type: Boolean!
}

type MovementSubscriptionPayload {
  mutation: MutationType!
  node: Movement
  updatedFields: [String!]
  previousValues: MovementPreviousValues
}

input MovementSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MovementWhereInput
  AND: [MovementSubscriptionWhereInput!]
  OR: [MovementSubscriptionWhereInput!]
  NOT: [MovementSubscriptionWhereInput!]
}

input MovementUpdateInput {
  date: DateTime
  deleted: Boolean
  designation: String
  documentId: Int
  htTotal: Float
  insertedId: Int
  price: Float
  quantite: String
  structureId: Int
  ttcTotal: Float
  tvaId: Int
  type: Boolean
}

input MovementUpdateManyMutationInput {
  date: DateTime
  deleted: Boolean
  designation: String
  documentId: Int
  htTotal: Float
  insertedId: Int
  price: Float
  quantite: String
  structureId: Int
  ttcTotal: Float
  tvaId: Int
  type: Boolean
}

input MovementWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  created: DateTime
  created_not: DateTime
  created_in: [DateTime!]
  created_not_in: [DateTime!]
  created_lt: DateTime
  created_lte: DateTime
  created_gt: DateTime
  created_gte: DateTime
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  deleted: Boolean
  deleted_not: Boolean
  designation: String
  designation_not: String
  designation_in: [String!]
  designation_not_in: [String!]
  designation_lt: String
  designation_lte: String
  designation_gt: String
  designation_gte: String
  designation_contains: String
  designation_not_contains: String
  designation_starts_with: String
  designation_not_starts_with: String
  designation_ends_with: String
  designation_not_ends_with: String
  documentId: Int
  documentId_not: Int
  documentId_in: [Int!]
  documentId_not_in: [Int!]
  documentId_lt: Int
  documentId_lte: Int
  documentId_gt: Int
  documentId_gte: Int
  htTotal: Float
  htTotal_not: Float
  htTotal_in: [Float!]
  htTotal_not_in: [Float!]
  htTotal_lt: Float
  htTotal_lte: Float
  htTotal_gt: Float
  htTotal_gte: Float
  insertedId: Int
  insertedId_not: Int
  insertedId_in: [Int!]
  insertedId_not_in: [Int!]
  insertedId_lt: Int
  insertedId_lte: Int
  insertedId_gt: Int
  insertedId_gte: Int
  price: Float
  price_not: Float
  price_in: [Float!]
  price_not_in: [Float!]
  price_lt: Float
  price_lte: Float
  price_gt: Float
  price_gte: Float
  quantite: String
  quantite_not: String
  quantite_in: [String!]
  quantite_not_in: [String!]
  quantite_lt: String
  quantite_lte: String
  quantite_gt: String
  quantite_gte: String
  quantite_contains: String
  quantite_not_contains: String
  quantite_starts_with: String
  quantite_not_starts_with: String
  quantite_ends_with: String
  quantite_not_ends_with: String
  structureId: Int
  structureId_not: Int
  structureId_in: [Int!]
  structureId_not_in: [Int!]
  structureId_lt: Int
  structureId_lte: Int
  structureId_gt: Int
  structureId_gte: Int
  ttcTotal: Float
  ttcTotal_not: Float
  ttcTotal_in: [Float!]
  ttcTotal_not_in: [Float!]
  ttcTotal_lt: Float
  ttcTotal_lte: Float
  ttcTotal_gt: Float
  ttcTotal_gte: Float
  tvaId: Int
  tvaId_not: Int
  tvaId_in: [Int!]
  tvaId_not_in: [Int!]
  tvaId_lt: Int
  tvaId_lte: Int
  tvaId_gt: Int
  tvaId_gte: Int
  type: Boolean
  type_not: Boolean
  AND: [MovementWhereInput!]
  OR: [MovementWhereInput!]
  NOT: [MovementWhereInput!]
}

input MovementWhereUniqueInput {
  id: Int
}

type Mutation {
  createClient(data: ClientCreateInput!): Client!
  updateClient(data: ClientUpdateInput!, where: ClientWhereUniqueInput!): Client
  updateManyClients(data: ClientUpdateManyMutationInput!, where: ClientWhereInput): BatchPayload!
  upsertClient(where: ClientWhereUniqueInput!, create: ClientCreateInput!, update: ClientUpdateInput!): Client!
  deleteClient(where: ClientWhereUniqueInput!): Client
  deleteManyClients(where: ClientWhereInput): BatchPayload!
  createContact(data: ContactCreateInput!): Contact!
  updateContact(data: ContactUpdateInput!, where: ContactWhereUniqueInput!): Contact
  updateManyContacts(data: ContactUpdateManyMutationInput!, where: ContactWhereInput): BatchPayload!
  upsertContact(where: ContactWhereUniqueInput!, create: ContactCreateInput!, update: ContactUpdateInput!): Contact!
  deleteContact(where: ContactWhereUniqueInput!): Contact
  deleteManyContacts(where: ContactWhereInput): BatchPayload!
  createCountry(data: CountryCreateInput!): Country!
  updateCountry(data: CountryUpdateInput!, where: CountryWhereUniqueInput!): Country
  updateManyCountries(data: CountryUpdateManyMutationInput!, where: CountryWhereInput): BatchPayload!
  upsertCountry(where: CountryWhereUniqueInput!, create: CountryCreateInput!, update: CountryUpdateInput!): Country!
  deleteCountry(where: CountryWhereUniqueInput!): Country
  deleteManyCountries(where: CountryWhereInput): BatchPayload!
  createDepartment(data: DepartmentCreateInput!): Department!
  updateDepartment(data: DepartmentUpdateInput!, where: DepartmentWhereUniqueInput!): Department
  updateManyDepartments(data: DepartmentUpdateManyMutationInput!, where: DepartmentWhereInput): BatchPayload!
  upsertDepartment(where: DepartmentWhereUniqueInput!, create: DepartmentCreateInput!, update: DepartmentUpdateInput!): Department!
  deleteDepartment(where: DepartmentWhereUniqueInput!): Department
  deleteManyDepartments(where: DepartmentWhereInput): BatchPayload!
  createDevisModele(data: DevisModeleCreateInput!): DevisModele!
  updateDevisModele(data: DevisModeleUpdateInput!, where: DevisModeleWhereUniqueInput!): DevisModele
  updateManyDevisModeles(data: DevisModeleUpdateManyMutationInput!, where: DevisModeleWhereInput): BatchPayload!
  upsertDevisModele(where: DevisModeleWhereUniqueInput!, create: DevisModeleCreateInput!, update: DevisModeleUpdateInput!): DevisModele!
  deleteDevisModele(where: DevisModeleWhereUniqueInput!): DevisModele
  deleteManyDevisModeles(where: DevisModeleWhereInput): BatchPayload!
  createDocument(data: DocumentCreateInput!): Document!
  updateDocument(data: DocumentUpdateInput!, where: DocumentWhereUniqueInput!): Document
  updateManyDocuments(data: DocumentUpdateManyMutationInput!, where: DocumentWhereInput): BatchPayload!
  upsertDocument(where: DocumentWhereUniqueInput!, create: DocumentCreateInput!, update: DocumentUpdateInput!): Document!
  deleteDocument(where: DocumentWhereUniqueInput!): Document
  deleteManyDocuments(where: DocumentWhereInput): BatchPayload!
  createDocumentType(data: DocumentTypeCreateInput!): DocumentType!
  updateDocumentType(data: DocumentTypeUpdateInput!, where: DocumentTypeWhereUniqueInput!): DocumentType
  updateManyDocumentTypes(data: DocumentTypeUpdateManyMutationInput!, where: DocumentTypeWhereInput): BatchPayload!
  upsertDocumentType(where: DocumentTypeWhereUniqueInput!, create: DocumentTypeCreateInput!, update: DocumentTypeUpdateInput!): DocumentType!
  deleteDocumentType(where: DocumentTypeWhereUniqueInput!): DocumentType
  deleteManyDocumentTypes(where: DocumentTypeWhereInput): BatchPayload!
  createEmpInfo(data: EmpInfoCreateInput!): EmpInfo!
  updateEmpInfo(data: EmpInfoUpdateInput!, where: EmpInfoWhereUniqueInput!): EmpInfo
  updateManyEmpInfoes(data: EmpInfoUpdateManyMutationInput!, where: EmpInfoWhereInput): BatchPayload!
  upsertEmpInfo(where: EmpInfoWhereUniqueInput!, create: EmpInfoCreateInput!, update: EmpInfoUpdateInput!): EmpInfo!
  deleteEmpInfo(where: EmpInfoWhereUniqueInput!): EmpInfo
  deleteManyEmpInfoes(where: EmpInfoWhereInput): BatchPayload!
  createEmploye(data: EmployeCreateInput!): Employe!
  updateEmploye(data: EmployeUpdateInput!, where: EmployeWhereUniqueInput!): Employe
  updateManyEmployes(data: EmployeUpdateManyMutationInput!, where: EmployeWhereInput): BatchPayload!
  upsertEmploye(where: EmployeWhereUniqueInput!, create: EmployeCreateInput!, update: EmployeUpdateInput!): Employe!
  deleteEmploye(where: EmployeWhereUniqueInput!): Employe
  deleteManyEmployes(where: EmployeWhereInput): BatchPayload!
  createEntity(data: EntityCreateInput!): Entity!
  updateEntity(data: EntityUpdateInput!, where: EntityWhereUniqueInput!): Entity
  updateManyEntities(data: EntityUpdateManyMutationInput!, where: EntityWhereInput): BatchPayload!
  upsertEntity(where: EntityWhereUniqueInput!, create: EntityCreateInput!, update: EntityUpdateInput!): Entity!
  deleteEntity(where: EntityWhereUniqueInput!): Entity
  deleteManyEntities(where: EntityWhereInput): BatchPayload!
  createFile(data: FileCreateInput!): File!
  updateFile(data: FileUpdateInput!, where: FileWhereUniqueInput!): File
  updateManyFiles(data: FileUpdateManyMutationInput!, where: FileWhereInput): BatchPayload!
  upsertFile(where: FileWhereUniqueInput!, create: FileCreateInput!, update: FileUpdateInput!): File!
  deleteFile(where: FileWhereUniqueInput!): File
  deleteManyFiles(where: FileWhereInput): BatchPayload!
  createJob(data: JobCreateInput!): Job!
  updateJob(data: JobUpdateInput!, where: JobWhereUniqueInput!): Job
  updateManyJobs(data: JobUpdateManyMutationInput!, where: JobWhereInput): BatchPayload!
  upsertJob(where: JobWhereUniqueInput!, create: JobCreateInput!, update: JobUpdateInput!): Job!
  deleteJob(where: JobWhereUniqueInput!): Job
  deleteManyJobs(where: JobWhereInput): BatchPayload!
  createLegalType(data: LegalTypeCreateInput!): LegalType!
  updateLegalType(data: LegalTypeUpdateInput!, where: LegalTypeWhereUniqueInput!): LegalType
  updateManyLegalTypes(data: LegalTypeUpdateManyMutationInput!, where: LegalTypeWhereInput): BatchPayload!
  upsertLegalType(where: LegalTypeWhereUniqueInput!, create: LegalTypeCreateInput!, update: LegalTypeUpdateInput!): LegalType!
  deleteLegalType(where: LegalTypeWhereUniqueInput!): LegalType
  deleteManyLegalTypes(where: LegalTypeWhereInput): BatchPayload!
  createMaction(data: MactionCreateInput!): Maction!
  updateMaction(data: MactionUpdateInput!, where: MactionWhereUniqueInput!): Maction
  updateManyMactions(data: MactionUpdateManyMutationInput!, where: MactionWhereInput): BatchPayload!
  upsertMaction(where: MactionWhereUniqueInput!, create: MactionCreateInput!, update: MactionUpdateInput!): Maction!
  deleteMaction(where: MactionWhereUniqueInput!): Maction
  deleteManyMactions(where: MactionWhereInput): BatchPayload!
  createMovement(data: MovementCreateInput!): Movement!
  updateMovement(data: MovementUpdateInput!, where: MovementWhereUniqueInput!): Movement
  updateManyMovements(data: MovementUpdateManyMutationInput!, where: MovementWhereInput): BatchPayload!
  upsertMovement(where: MovementWhereUniqueInput!, create: MovementCreateInput!, update: MovementUpdateInput!): Movement!
  deleteMovement(where: MovementWhereUniqueInput!): Movement
  deleteManyMovements(where: MovementWhereInput): BatchPayload!
  createPerson(data: PersonCreateInput!): Person!
  updatePerson(data: PersonUpdateInput!, where: PersonWhereUniqueInput!): Person
  updateManyPersons(data: PersonUpdateManyMutationInput!, where: PersonWhereInput): BatchPayload!
  upsertPerson(where: PersonWhereUniqueInput!, create: PersonCreateInput!, update: PersonUpdateInput!): Person!
  deletePerson(where: PersonWhereUniqueInput!): Person
  deleteManyPersons(where: PersonWhereInput): BatchPayload!
  createStructure(data: StructureCreateInput!): Structure!
  updateStructure(data: StructureUpdateInput!, where: StructureWhereUniqueInput!): Structure
  updateManyStructures(data: StructureUpdateManyMutationInput!, where: StructureWhereInput): BatchPayload!
  upsertStructure(where: StructureWhereUniqueInput!, create: StructureCreateInput!, update: StructureUpdateInput!): Structure!
  deleteStructure(where: StructureWhereUniqueInput!): Structure
  deleteManyStructures(where: StructureWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Person {
  id: Int!
  firstname: String
  lastname: String
  createdAt: DateTime
  updatedAt: DateTime
}

type PersonConnection {
  pageInfo: PageInfo!
  edges: [PersonEdge]!
  aggregate: AggregatePerson!
}

input PersonCreateInput {
  id: Int
  firstname: String
  lastname: String
}

input PersonCreateOneInput {
  create: PersonCreateInput
  connect: PersonWhereUniqueInput
}

type PersonEdge {
  node: Person!
  cursor: String!
}

enum PersonOrderByInput {
  id_ASC
  id_DESC
  firstname_ASC
  firstname_DESC
  lastname_ASC
  lastname_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PersonPreviousValues {
  id: Int!
  firstname: String
  lastname: String
  createdAt: DateTime
  updatedAt: DateTime
}

type PersonSubscriptionPayload {
  mutation: MutationType!
  node: Person
  updatedFields: [String!]
  previousValues: PersonPreviousValues
}

input PersonSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PersonWhereInput
  AND: [PersonSubscriptionWhereInput!]
  OR: [PersonSubscriptionWhereInput!]
  NOT: [PersonSubscriptionWhereInput!]
}

input PersonUpdateDataInput {
  firstname: String
  lastname: String
}

input PersonUpdateInput {
  firstname: String
  lastname: String
}

input PersonUpdateManyMutationInput {
  firstname: String
  lastname: String
}

input PersonUpdateOneInput {
  create: PersonCreateInput
  update: PersonUpdateDataInput
  upsert: PersonUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: PersonWhereUniqueInput
}

input PersonUpsertNestedInput {
  update: PersonUpdateDataInput!
  create: PersonCreateInput!
}

input PersonWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  firstname: String
  firstname_not: String
  firstname_in: [String!]
  firstname_not_in: [String!]
  firstname_lt: String
  firstname_lte: String
  firstname_gt: String
  firstname_gte: String
  firstname_contains: String
  firstname_not_contains: String
  firstname_starts_with: String
  firstname_not_starts_with: String
  firstname_ends_with: String
  firstname_not_ends_with: String
  lastname: String
  lastname_not: String
  lastname_in: [String!]
  lastname_not_in: [String!]
  lastname_lt: String
  lastname_lte: String
  lastname_gt: String
  lastname_gte: String
  lastname_contains: String
  lastname_not_contains: String
  lastname_starts_with: String
  lastname_not_starts_with: String
  lastname_ends_with: String
  lastname_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [PersonWhereInput!]
  OR: [PersonWhereInput!]
  NOT: [PersonWhereInput!]
}

input PersonWhereUniqueInput {
  id: Int
}

type Query {
  client(where: ClientWhereUniqueInput!): Client
  clients(where: ClientWhereInput, orderBy: ClientOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Client]!
  clientsConnection(where: ClientWhereInput, orderBy: ClientOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ClientConnection!
  contact(where: ContactWhereUniqueInput!): Contact
  contacts(where: ContactWhereInput, orderBy: ContactOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Contact]!
  contactsConnection(where: ContactWhereInput, orderBy: ContactOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ContactConnection!
  country(where: CountryWhereUniqueInput!): Country
  countries(where: CountryWhereInput, orderBy: CountryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Country]!
  countriesConnection(where: CountryWhereInput, orderBy: CountryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CountryConnection!
  department(where: DepartmentWhereUniqueInput!): Department
  departments(where: DepartmentWhereInput, orderBy: DepartmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Department]!
  departmentsConnection(where: DepartmentWhereInput, orderBy: DepartmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DepartmentConnection!
  devisModele(where: DevisModeleWhereUniqueInput!): DevisModele
  devisModeles(where: DevisModeleWhereInput, orderBy: DevisModeleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [DevisModele]!
  devisModelesConnection(where: DevisModeleWhereInput, orderBy: DevisModeleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DevisModeleConnection!
  document(where: DocumentWhereUniqueInput!): Document
  documents(where: DocumentWhereInput, orderBy: DocumentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Document]!
  documentsConnection(where: DocumentWhereInput, orderBy: DocumentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DocumentConnection!
  documentType(where: DocumentTypeWhereUniqueInput!): DocumentType
  documentTypes(where: DocumentTypeWhereInput, orderBy: DocumentTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [DocumentType]!
  documentTypesConnection(where: DocumentTypeWhereInput, orderBy: DocumentTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DocumentTypeConnection!
  empInfo(where: EmpInfoWhereUniqueInput!): EmpInfo
  empInfoes(where: EmpInfoWhereInput, orderBy: EmpInfoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [EmpInfo]!
  empInfoesConnection(where: EmpInfoWhereInput, orderBy: EmpInfoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EmpInfoConnection!
  employe(where: EmployeWhereUniqueInput!): Employe
  employes(where: EmployeWhereInput, orderBy: EmployeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Employe]!
  employesConnection(where: EmployeWhereInput, orderBy: EmployeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EmployeConnection!
  entity(where: EntityWhereUniqueInput!): Entity
  entities(where: EntityWhereInput, orderBy: EntityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Entity]!
  entitiesConnection(where: EntityWhereInput, orderBy: EntityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EntityConnection!
  file(where: FileWhereUniqueInput!): File
  files(where: FileWhereInput, orderBy: FileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [File]!
  filesConnection(where: FileWhereInput, orderBy: FileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FileConnection!
  job(where: JobWhereUniqueInput!): Job
  jobs(where: JobWhereInput, orderBy: JobOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Job]!
  jobsConnection(where: JobWhereInput, orderBy: JobOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): JobConnection!
  legalType(where: LegalTypeWhereUniqueInput!): LegalType
  legalTypes(where: LegalTypeWhereInput, orderBy: LegalTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [LegalType]!
  legalTypesConnection(where: LegalTypeWhereInput, orderBy: LegalTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LegalTypeConnection!
  maction(where: MactionWhereUniqueInput!): Maction
  mactions(where: MactionWhereInput, orderBy: MactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Maction]!
  mactionsConnection(where: MactionWhereInput, orderBy: MactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MactionConnection!
  movement(where: MovementWhereUniqueInput!): Movement
  movements(where: MovementWhereInput, orderBy: MovementOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Movement]!
  movementsConnection(where: MovementWhereInput, orderBy: MovementOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MovementConnection!
  person(where: PersonWhereUniqueInput!): Person
  persons(where: PersonWhereInput, orderBy: PersonOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Person]!
  personsConnection(where: PersonWhereInput, orderBy: PersonOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PersonConnection!
  structure(where: StructureWhereUniqueInput!): Structure
  structures(where: StructureWhereInput, orderBy: StructureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Structure]!
  structuresConnection(where: StructureWhereInput, orderBy: StructureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StructureConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Structure {
  id: Int!
  raison_sociale: String
  createdAt: DateTime
  updatedAt: DateTime
}

type StructureConnection {
  pageInfo: PageInfo!
  edges: [StructureEdge]!
  aggregate: AggregateStructure!
}

input StructureCreateInput {
  id: Int
  raison_sociale: String
}

input StructureCreateOneInput {
  create: StructureCreateInput
  connect: StructureWhereUniqueInput
}

type StructureEdge {
  node: Structure!
  cursor: String!
}

enum StructureOrderByInput {
  id_ASC
  id_DESC
  raison_sociale_ASC
  raison_sociale_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type StructurePreviousValues {
  id: Int!
  raison_sociale: String
  createdAt: DateTime
  updatedAt: DateTime
}

type StructureSubscriptionPayload {
  mutation: MutationType!
  node: Structure
  updatedFields: [String!]
  previousValues: StructurePreviousValues
}

input StructureSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StructureWhereInput
  AND: [StructureSubscriptionWhereInput!]
  OR: [StructureSubscriptionWhereInput!]
  NOT: [StructureSubscriptionWhereInput!]
}

input StructureUpdateDataInput {
  raison_sociale: String
}

input StructureUpdateInput {
  raison_sociale: String
}

input StructureUpdateManyMutationInput {
  raison_sociale: String
}

input StructureUpdateOneInput {
  create: StructureCreateInput
  update: StructureUpdateDataInput
  upsert: StructureUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: StructureWhereUniqueInput
}

input StructureUpsertNestedInput {
  update: StructureUpdateDataInput!
  create: StructureCreateInput!
}

input StructureWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  raison_sociale: String
  raison_sociale_not: String
  raison_sociale_in: [String!]
  raison_sociale_not_in: [String!]
  raison_sociale_lt: String
  raison_sociale_lte: String
  raison_sociale_gt: String
  raison_sociale_gte: String
  raison_sociale_contains: String
  raison_sociale_not_contains: String
  raison_sociale_starts_with: String
  raison_sociale_not_starts_with: String
  raison_sociale_ends_with: String
  raison_sociale_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [StructureWhereInput!]
  OR: [StructureWhereInput!]
  NOT: [StructureWhereInput!]
}

input StructureWhereUniqueInput {
  id: Int
}

type Subscription {
  client(where: ClientSubscriptionWhereInput): ClientSubscriptionPayload
  contact(where: ContactSubscriptionWhereInput): ContactSubscriptionPayload
  country(where: CountrySubscriptionWhereInput): CountrySubscriptionPayload
  department(where: DepartmentSubscriptionWhereInput): DepartmentSubscriptionPayload
  devisModele(where: DevisModeleSubscriptionWhereInput): DevisModeleSubscriptionPayload
  document(where: DocumentSubscriptionWhereInput): DocumentSubscriptionPayload
  documentType(where: DocumentTypeSubscriptionWhereInput): DocumentTypeSubscriptionPayload
  empInfo(where: EmpInfoSubscriptionWhereInput): EmpInfoSubscriptionPayload
  employe(where: EmployeSubscriptionWhereInput): EmployeSubscriptionPayload
  entity(where: EntitySubscriptionWhereInput): EntitySubscriptionPayload
  file(where: FileSubscriptionWhereInput): FileSubscriptionPayload
  job(where: JobSubscriptionWhereInput): JobSubscriptionPayload
  legalType(where: LegalTypeSubscriptionWhereInput): LegalTypeSubscriptionPayload
  maction(where: MactionSubscriptionWhereInput): MactionSubscriptionPayload
  movement(where: MovementSubscriptionWhereInput): MovementSubscriptionPayload
  person(where: PersonSubscriptionWhereInput): PersonSubscriptionPayload
  structure(where: StructureSubscriptionWhereInput): StructureSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: Int!
  email: String!
  nom: String
  prenom: String
  password: String!
  telephone: String
  telephone2: String
  ville: String
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: Int
  email: String!
  nom: String
  prenom: String
  password: String!
  telephone: String
  telephone2: String
  ville: String
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  nom_ASC
  nom_DESC
  prenom_ASC
  prenom_DESC
  password_ASC
  password_DESC
  telephone_ASC
  telephone_DESC
  telephone2_ASC
  telephone2_DESC
  ville_ASC
  ville_DESC
}

type UserPreviousValues {
  id: Int!
  email: String!
  nom: String
  prenom: String
  password: String!
  telephone: String
  telephone2: String
  ville: String
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  email: String
  nom: String
  prenom: String
  password: String
  telephone: String
  telephone2: String
  ville: String
}

input UserUpdateManyMutationInput {
  email: String
  nom: String
  prenom: String
  password: String
  telephone: String
  telephone2: String
  ville: String
}

input UserWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  nom: String
  nom_not: String
  nom_in: [String!]
  nom_not_in: [String!]
  nom_lt: String
  nom_lte: String
  nom_gt: String
  nom_gte: String
  nom_contains: String
  nom_not_contains: String
  nom_starts_with: String
  nom_not_starts_with: String
  nom_ends_with: String
  nom_not_ends_with: String
  prenom: String
  prenom_not: String
  prenom_in: [String!]
  prenom_not_in: [String!]
  prenom_lt: String
  prenom_lte: String
  prenom_gt: String
  prenom_gte: String
  prenom_contains: String
  prenom_not_contains: String
  prenom_starts_with: String
  prenom_not_starts_with: String
  prenom_ends_with: String
  prenom_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  telephone: String
  telephone_not: String
  telephone_in: [String!]
  telephone_not_in: [String!]
  telephone_lt: String
  telephone_lte: String
  telephone_gt: String
  telephone_gte: String
  telephone_contains: String
  telephone_not_contains: String
  telephone_starts_with: String
  telephone_not_starts_with: String
  telephone_ends_with: String
  telephone_not_ends_with: String
  telephone2: String
  telephone2_not: String
  telephone2_in: [String!]
  telephone2_not_in: [String!]
  telephone2_lt: String
  telephone2_lte: String
  telephone2_gt: String
  telephone2_gte: String
  telephone2_contains: String
  telephone2_not_contains: String
  telephone2_starts_with: String
  telephone2_not_starts_with: String
  telephone2_ends_with: String
  telephone2_not_ends_with: String
  ville: String
  ville_not: String
  ville_in: [String!]
  ville_not_in: [String!]
  ville_lt: String
  ville_lte: String
  ville_gt: String
  ville_gte: String
  ville_contains: String
  ville_not_contains: String
  ville_starts_with: String
  ville_not_starts_with: String
  ville_ends_with: String
  ville_not_ends_with: String
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: Int
}
`
      }
    