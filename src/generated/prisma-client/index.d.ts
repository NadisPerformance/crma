// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  client: (where?: ClientWhereInput) => Promise<boolean>;
  contact: (where?: ContactWhereInput) => Promise<boolean>;
  country: (where?: CountryWhereInput) => Promise<boolean>;
  department: (where?: DepartmentWhereInput) => Promise<boolean>;
  devisModele: (where?: DevisModeleWhereInput) => Promise<boolean>;
  document: (where?: DocumentWhereInput) => Promise<boolean>;
  documentType: (where?: DocumentTypeWhereInput) => Promise<boolean>;
  empInfo: (where?: EmpInfoWhereInput) => Promise<boolean>;
  employe: (where?: EmployeWhereInput) => Promise<boolean>;
  entity: (where?: EntityWhereInput) => Promise<boolean>;
  file: (where?: FileWhereInput) => Promise<boolean>;
  job: (where?: JobWhereInput) => Promise<boolean>;
  legalType: (where?: LegalTypeWhereInput) => Promise<boolean>;
  maction: (where?: MactionWhereInput) => Promise<boolean>;
  movement: (where?: MovementWhereInput) => Promise<boolean>;
  person: (where?: PersonWhereInput) => Promise<boolean>;
  structure: (where?: StructureWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  client: (where: ClientWhereUniqueInput) => ClientNullablePromise;
  clients: (args?: {
    where?: ClientWhereInput;
    orderBy?: ClientOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Client>;
  clientsConnection: (args?: {
    where?: ClientWhereInput;
    orderBy?: ClientOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ClientConnectionPromise;
  contact: (where: ContactWhereUniqueInput) => ContactNullablePromise;
  contacts: (args?: {
    where?: ContactWhereInput;
    orderBy?: ContactOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Contact>;
  contactsConnection: (args?: {
    where?: ContactWhereInput;
    orderBy?: ContactOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ContactConnectionPromise;
  country: (where: CountryWhereUniqueInput) => CountryNullablePromise;
  countries: (args?: {
    where?: CountryWhereInput;
    orderBy?: CountryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Country>;
  countriesConnection: (args?: {
    where?: CountryWhereInput;
    orderBy?: CountryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CountryConnectionPromise;
  department: (where: DepartmentWhereUniqueInput) => DepartmentNullablePromise;
  departments: (args?: {
    where?: DepartmentWhereInput;
    orderBy?: DepartmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Department>;
  departmentsConnection: (args?: {
    where?: DepartmentWhereInput;
    orderBy?: DepartmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DepartmentConnectionPromise;
  devisModele: (
    where: DevisModeleWhereUniqueInput
  ) => DevisModeleNullablePromise;
  devisModeles: (args?: {
    where?: DevisModeleWhereInput;
    orderBy?: DevisModeleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<DevisModele>;
  devisModelesConnection: (args?: {
    where?: DevisModeleWhereInput;
    orderBy?: DevisModeleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DevisModeleConnectionPromise;
  document: (where: DocumentWhereUniqueInput) => DocumentNullablePromise;
  documents: (args?: {
    where?: DocumentWhereInput;
    orderBy?: DocumentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Document>;
  documentsConnection: (args?: {
    where?: DocumentWhereInput;
    orderBy?: DocumentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DocumentConnectionPromise;
  documentType: (
    where: DocumentTypeWhereUniqueInput
  ) => DocumentTypeNullablePromise;
  documentTypes: (args?: {
    where?: DocumentTypeWhereInput;
    orderBy?: DocumentTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<DocumentType>;
  documentTypesConnection: (args?: {
    where?: DocumentTypeWhereInput;
    orderBy?: DocumentTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DocumentTypeConnectionPromise;
  empInfo: (where: EmpInfoWhereUniqueInput) => EmpInfoNullablePromise;
  empInfoes: (args?: {
    where?: EmpInfoWhereInput;
    orderBy?: EmpInfoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<EmpInfo>;
  empInfoesConnection: (args?: {
    where?: EmpInfoWhereInput;
    orderBy?: EmpInfoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EmpInfoConnectionPromise;
  employe: (where: EmployeWhereUniqueInput) => EmployeNullablePromise;
  employes: (args?: {
    where?: EmployeWhereInput;
    orderBy?: EmployeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Employe>;
  employesConnection: (args?: {
    where?: EmployeWhereInput;
    orderBy?: EmployeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EmployeConnectionPromise;
  entity: (where: EntityWhereUniqueInput) => EntityNullablePromise;
  entities: (args?: {
    where?: EntityWhereInput;
    orderBy?: EntityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Entity>;
  entitiesConnection: (args?: {
    where?: EntityWhereInput;
    orderBy?: EntityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EntityConnectionPromise;
  file: (where: FileWhereUniqueInput) => FileNullablePromise;
  files: (args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<File>;
  filesConnection: (args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FileConnectionPromise;
  job: (where: JobWhereUniqueInput) => JobNullablePromise;
  jobs: (args?: {
    where?: JobWhereInput;
    orderBy?: JobOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Job>;
  jobsConnection: (args?: {
    where?: JobWhereInput;
    orderBy?: JobOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => JobConnectionPromise;
  legalType: (where: LegalTypeWhereUniqueInput) => LegalTypeNullablePromise;
  legalTypes: (args?: {
    where?: LegalTypeWhereInput;
    orderBy?: LegalTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<LegalType>;
  legalTypesConnection: (args?: {
    where?: LegalTypeWhereInput;
    orderBy?: LegalTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LegalTypeConnectionPromise;
  maction: (where: MactionWhereUniqueInput) => MactionNullablePromise;
  mactions: (args?: {
    where?: MactionWhereInput;
    orderBy?: MactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Maction>;
  mactionsConnection: (args?: {
    where?: MactionWhereInput;
    orderBy?: MactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MactionConnectionPromise;
  movement: (where: MovementWhereUniqueInput) => MovementNullablePromise;
  movements: (args?: {
    where?: MovementWhereInput;
    orderBy?: MovementOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Movement>;
  movementsConnection: (args?: {
    where?: MovementWhereInput;
    orderBy?: MovementOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MovementConnectionPromise;
  person: (where: PersonWhereUniqueInput) => PersonNullablePromise;
  persons: (args?: {
    where?: PersonWhereInput;
    orderBy?: PersonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Person>;
  personsConnection: (args?: {
    where?: PersonWhereInput;
    orderBy?: PersonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PersonConnectionPromise;
  structure: (where: StructureWhereUniqueInput) => StructureNullablePromise;
  structures: (args?: {
    where?: StructureWhereInput;
    orderBy?: StructureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Structure>;
  structuresConnection: (args?: {
    where?: StructureWhereInput;
    orderBy?: StructureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StructureConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createClient: (data: ClientCreateInput) => ClientPromise;
  updateClient: (args: {
    data: ClientUpdateInput;
    where: ClientWhereUniqueInput;
  }) => ClientPromise;
  updateManyClients: (args: {
    data: ClientUpdateManyMutationInput;
    where?: ClientWhereInput;
  }) => BatchPayloadPromise;
  upsertClient: (args: {
    where: ClientWhereUniqueInput;
    create: ClientCreateInput;
    update: ClientUpdateInput;
  }) => ClientPromise;
  deleteClient: (where: ClientWhereUniqueInput) => ClientPromise;
  deleteManyClients: (where?: ClientWhereInput) => BatchPayloadPromise;
  createContact: (data: ContactCreateInput) => ContactPromise;
  updateContact: (args: {
    data: ContactUpdateInput;
    where: ContactWhereUniqueInput;
  }) => ContactPromise;
  updateManyContacts: (args: {
    data: ContactUpdateManyMutationInput;
    where?: ContactWhereInput;
  }) => BatchPayloadPromise;
  upsertContact: (args: {
    where: ContactWhereUniqueInput;
    create: ContactCreateInput;
    update: ContactUpdateInput;
  }) => ContactPromise;
  deleteContact: (where: ContactWhereUniqueInput) => ContactPromise;
  deleteManyContacts: (where?: ContactWhereInput) => BatchPayloadPromise;
  createCountry: (data: CountryCreateInput) => CountryPromise;
  updateCountry: (args: {
    data: CountryUpdateInput;
    where: CountryWhereUniqueInput;
  }) => CountryPromise;
  updateManyCountries: (args: {
    data: CountryUpdateManyMutationInput;
    where?: CountryWhereInput;
  }) => BatchPayloadPromise;
  upsertCountry: (args: {
    where: CountryWhereUniqueInput;
    create: CountryCreateInput;
    update: CountryUpdateInput;
  }) => CountryPromise;
  deleteCountry: (where: CountryWhereUniqueInput) => CountryPromise;
  deleteManyCountries: (where?: CountryWhereInput) => BatchPayloadPromise;
  createDepartment: (data: DepartmentCreateInput) => DepartmentPromise;
  updateDepartment: (args: {
    data: DepartmentUpdateInput;
    where: DepartmentWhereUniqueInput;
  }) => DepartmentPromise;
  updateManyDepartments: (args: {
    data: DepartmentUpdateManyMutationInput;
    where?: DepartmentWhereInput;
  }) => BatchPayloadPromise;
  upsertDepartment: (args: {
    where: DepartmentWhereUniqueInput;
    create: DepartmentCreateInput;
    update: DepartmentUpdateInput;
  }) => DepartmentPromise;
  deleteDepartment: (where: DepartmentWhereUniqueInput) => DepartmentPromise;
  deleteManyDepartments: (where?: DepartmentWhereInput) => BatchPayloadPromise;
  createDevisModele: (data: DevisModeleCreateInput) => DevisModelePromise;
  updateDevisModele: (args: {
    data: DevisModeleUpdateInput;
    where: DevisModeleWhereUniqueInput;
  }) => DevisModelePromise;
  updateManyDevisModeles: (args: {
    data: DevisModeleUpdateManyMutationInput;
    where?: DevisModeleWhereInput;
  }) => BatchPayloadPromise;
  upsertDevisModele: (args: {
    where: DevisModeleWhereUniqueInput;
    create: DevisModeleCreateInput;
    update: DevisModeleUpdateInput;
  }) => DevisModelePromise;
  deleteDevisModele: (where: DevisModeleWhereUniqueInput) => DevisModelePromise;
  deleteManyDevisModeles: (
    where?: DevisModeleWhereInput
  ) => BatchPayloadPromise;
  createDocument: (data: DocumentCreateInput) => DocumentPromise;
  updateDocument: (args: {
    data: DocumentUpdateInput;
    where: DocumentWhereUniqueInput;
  }) => DocumentPromise;
  updateManyDocuments: (args: {
    data: DocumentUpdateManyMutationInput;
    where?: DocumentWhereInput;
  }) => BatchPayloadPromise;
  upsertDocument: (args: {
    where: DocumentWhereUniqueInput;
    create: DocumentCreateInput;
    update: DocumentUpdateInput;
  }) => DocumentPromise;
  deleteDocument: (where: DocumentWhereUniqueInput) => DocumentPromise;
  deleteManyDocuments: (where?: DocumentWhereInput) => BatchPayloadPromise;
  createDocumentType: (data: DocumentTypeCreateInput) => DocumentTypePromise;
  updateDocumentType: (args: {
    data: DocumentTypeUpdateInput;
    where: DocumentTypeWhereUniqueInput;
  }) => DocumentTypePromise;
  updateManyDocumentTypes: (args: {
    data: DocumentTypeUpdateManyMutationInput;
    where?: DocumentTypeWhereInput;
  }) => BatchPayloadPromise;
  upsertDocumentType: (args: {
    where: DocumentTypeWhereUniqueInput;
    create: DocumentTypeCreateInput;
    update: DocumentTypeUpdateInput;
  }) => DocumentTypePromise;
  deleteDocumentType: (
    where: DocumentTypeWhereUniqueInput
  ) => DocumentTypePromise;
  deleteManyDocumentTypes: (
    where?: DocumentTypeWhereInput
  ) => BatchPayloadPromise;
  createEmpInfo: (data: EmpInfoCreateInput) => EmpInfoPromise;
  updateEmpInfo: (args: {
    data: EmpInfoUpdateInput;
    where: EmpInfoWhereUniqueInput;
  }) => EmpInfoPromise;
  updateManyEmpInfoes: (args: {
    data: EmpInfoUpdateManyMutationInput;
    where?: EmpInfoWhereInput;
  }) => BatchPayloadPromise;
  upsertEmpInfo: (args: {
    where: EmpInfoWhereUniqueInput;
    create: EmpInfoCreateInput;
    update: EmpInfoUpdateInput;
  }) => EmpInfoPromise;
  deleteEmpInfo: (where: EmpInfoWhereUniqueInput) => EmpInfoPromise;
  deleteManyEmpInfoes: (where?: EmpInfoWhereInput) => BatchPayloadPromise;
  createEmploye: (data: EmployeCreateInput) => EmployePromise;
  updateEmploye: (args: {
    data: EmployeUpdateInput;
    where: EmployeWhereUniqueInput;
  }) => EmployePromise;
  updateManyEmployes: (args: {
    data: EmployeUpdateManyMutationInput;
    where?: EmployeWhereInput;
  }) => BatchPayloadPromise;
  upsertEmploye: (args: {
    where: EmployeWhereUniqueInput;
    create: EmployeCreateInput;
    update: EmployeUpdateInput;
  }) => EmployePromise;
  deleteEmploye: (where: EmployeWhereUniqueInput) => EmployePromise;
  deleteManyEmployes: (where?: EmployeWhereInput) => BatchPayloadPromise;
  createEntity: (data: EntityCreateInput) => EntityPromise;
  updateEntity: (args: {
    data: EntityUpdateInput;
    where: EntityWhereUniqueInput;
  }) => EntityPromise;
  updateManyEntities: (args: {
    data: EntityUpdateManyMutationInput;
    where?: EntityWhereInput;
  }) => BatchPayloadPromise;
  upsertEntity: (args: {
    where: EntityWhereUniqueInput;
    create: EntityCreateInput;
    update: EntityUpdateInput;
  }) => EntityPromise;
  deleteEntity: (where: EntityWhereUniqueInput) => EntityPromise;
  deleteManyEntities: (where?: EntityWhereInput) => BatchPayloadPromise;
  createFile: (data: FileCreateInput) => FilePromise;
  updateFile: (args: {
    data: FileUpdateInput;
    where: FileWhereUniqueInput;
  }) => FilePromise;
  updateManyFiles: (args: {
    data: FileUpdateManyMutationInput;
    where?: FileWhereInput;
  }) => BatchPayloadPromise;
  upsertFile: (args: {
    where: FileWhereUniqueInput;
    create: FileCreateInput;
    update: FileUpdateInput;
  }) => FilePromise;
  deleteFile: (where: FileWhereUniqueInput) => FilePromise;
  deleteManyFiles: (where?: FileWhereInput) => BatchPayloadPromise;
  createJob: (data: JobCreateInput) => JobPromise;
  updateJob: (args: {
    data: JobUpdateInput;
    where: JobWhereUniqueInput;
  }) => JobPromise;
  updateManyJobs: (args: {
    data: JobUpdateManyMutationInput;
    where?: JobWhereInput;
  }) => BatchPayloadPromise;
  upsertJob: (args: {
    where: JobWhereUniqueInput;
    create: JobCreateInput;
    update: JobUpdateInput;
  }) => JobPromise;
  deleteJob: (where: JobWhereUniqueInput) => JobPromise;
  deleteManyJobs: (where?: JobWhereInput) => BatchPayloadPromise;
  createLegalType: (data: LegalTypeCreateInput) => LegalTypePromise;
  updateLegalType: (args: {
    data: LegalTypeUpdateInput;
    where: LegalTypeWhereUniqueInput;
  }) => LegalTypePromise;
  updateManyLegalTypes: (args: {
    data: LegalTypeUpdateManyMutationInput;
    where?: LegalTypeWhereInput;
  }) => BatchPayloadPromise;
  upsertLegalType: (args: {
    where: LegalTypeWhereUniqueInput;
    create: LegalTypeCreateInput;
    update: LegalTypeUpdateInput;
  }) => LegalTypePromise;
  deleteLegalType: (where: LegalTypeWhereUniqueInput) => LegalTypePromise;
  deleteManyLegalTypes: (where?: LegalTypeWhereInput) => BatchPayloadPromise;
  createMaction: (data: MactionCreateInput) => MactionPromise;
  updateMaction: (args: {
    data: MactionUpdateInput;
    where: MactionWhereUniqueInput;
  }) => MactionPromise;
  updateManyMactions: (args: {
    data: MactionUpdateManyMutationInput;
    where?: MactionWhereInput;
  }) => BatchPayloadPromise;
  upsertMaction: (args: {
    where: MactionWhereUniqueInput;
    create: MactionCreateInput;
    update: MactionUpdateInput;
  }) => MactionPromise;
  deleteMaction: (where: MactionWhereUniqueInput) => MactionPromise;
  deleteManyMactions: (where?: MactionWhereInput) => BatchPayloadPromise;
  createMovement: (data: MovementCreateInput) => MovementPromise;
  updateMovement: (args: {
    data: MovementUpdateInput;
    where: MovementWhereUniqueInput;
  }) => MovementPromise;
  updateManyMovements: (args: {
    data: MovementUpdateManyMutationInput;
    where?: MovementWhereInput;
  }) => BatchPayloadPromise;
  upsertMovement: (args: {
    where: MovementWhereUniqueInput;
    create: MovementCreateInput;
    update: MovementUpdateInput;
  }) => MovementPromise;
  deleteMovement: (where: MovementWhereUniqueInput) => MovementPromise;
  deleteManyMovements: (where?: MovementWhereInput) => BatchPayloadPromise;
  createPerson: (data: PersonCreateInput) => PersonPromise;
  updatePerson: (args: {
    data: PersonUpdateInput;
    where: PersonWhereUniqueInput;
  }) => PersonPromise;
  updateManyPersons: (args: {
    data: PersonUpdateManyMutationInput;
    where?: PersonWhereInput;
  }) => BatchPayloadPromise;
  upsertPerson: (args: {
    where: PersonWhereUniqueInput;
    create: PersonCreateInput;
    update: PersonUpdateInput;
  }) => PersonPromise;
  deletePerson: (where: PersonWhereUniqueInput) => PersonPromise;
  deleteManyPersons: (where?: PersonWhereInput) => BatchPayloadPromise;
  createStructure: (data: StructureCreateInput) => StructurePromise;
  updateStructure: (args: {
    data: StructureUpdateInput;
    where: StructureWhereUniqueInput;
  }) => StructurePromise;
  updateManyStructures: (args: {
    data: StructureUpdateManyMutationInput;
    where?: StructureWhereInput;
  }) => BatchPayloadPromise;
  upsertStructure: (args: {
    where: StructureWhereUniqueInput;
    create: StructureCreateInput;
    update: StructureUpdateInput;
  }) => StructurePromise;
  deleteStructure: (where: StructureWhereUniqueInput) => StructurePromise;
  deleteManyStructures: (where?: StructureWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  client: (
    where?: ClientSubscriptionWhereInput
  ) => ClientSubscriptionPayloadSubscription;
  contact: (
    where?: ContactSubscriptionWhereInput
  ) => ContactSubscriptionPayloadSubscription;
  country: (
    where?: CountrySubscriptionWhereInput
  ) => CountrySubscriptionPayloadSubscription;
  department: (
    where?: DepartmentSubscriptionWhereInput
  ) => DepartmentSubscriptionPayloadSubscription;
  devisModele: (
    where?: DevisModeleSubscriptionWhereInput
  ) => DevisModeleSubscriptionPayloadSubscription;
  document: (
    where?: DocumentSubscriptionWhereInput
  ) => DocumentSubscriptionPayloadSubscription;
  documentType: (
    where?: DocumentTypeSubscriptionWhereInput
  ) => DocumentTypeSubscriptionPayloadSubscription;
  empInfo: (
    where?: EmpInfoSubscriptionWhereInput
  ) => EmpInfoSubscriptionPayloadSubscription;
  employe: (
    where?: EmployeSubscriptionWhereInput
  ) => EmployeSubscriptionPayloadSubscription;
  entity: (
    where?: EntitySubscriptionWhereInput
  ) => EntitySubscriptionPayloadSubscription;
  file: (
    where?: FileSubscriptionWhereInput
  ) => FileSubscriptionPayloadSubscription;
  job: (
    where?: JobSubscriptionWhereInput
  ) => JobSubscriptionPayloadSubscription;
  legalType: (
    where?: LegalTypeSubscriptionWhereInput
  ) => LegalTypeSubscriptionPayloadSubscription;
  maction: (
    where?: MactionSubscriptionWhereInput
  ) => MactionSubscriptionPayloadSubscription;
  movement: (
    where?: MovementSubscriptionWhereInput
  ) => MovementSubscriptionPayloadSubscription;
  person: (
    where?: PersonSubscriptionWhereInput
  ) => PersonSubscriptionPayloadSubscription;
  structure: (
    where?: StructureSubscriptionWhereInput
  ) => StructureSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ClientOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ContactOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "activite_ASC"
  | "activite_DESC"
  | "adresse_ASC"
  | "adresse_DESC"
  | "adresseComplement_ASC"
  | "adresseComplement_DESC"
  | "civilite_ASC"
  | "civilite_DESC"
  | "comment_ASC"
  | "comment_DESC"
  | "companyName_ASC"
  | "companyName_DESC"
  | "countryId_ASC"
  | "countryId_DESC"
  | "cp_ASC"
  | "cp_DESC"
  | "created_ASC"
  | "created_DESC"
  | "email_ASC"
  | "email_DESC"
  | "insertedId_ASC"
  | "insertedId_DESC"
  | "lienSite_ASC"
  | "lienSite_DESC"
  | "nom_ASC"
  | "nom_DESC"
  | "prenom_ASC"
  | "prenom_DESC"
  | "structureId_ASC"
  | "structureId_DESC"
  | "tel1_ASC"
  | "tel1_DESC"
  | "tel2_ASC"
  | "tel2_DESC"
  | "ville_ASC"
  | "ville_DESC";

export type CountryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "code_ASC"
  | "code_DESC"
  | "name_ASC"
  | "name_DESC"
  | "ordre_ASC"
  | "ordre_DESC";

export type DepartmentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "created_ASC"
  | "created_DESC"
  | "deleted_ASC"
  | "deleted_DESC"
  | "location_ASC"
  | "location_DESC"
  | "managerId_ASC"
  | "managerId_DESC"
  | "name_ASC"
  | "name_DESC"
  | "structureId_ASC"
  | "structureId_DESC"
  | "updated_ASC"
  | "updated_DESC";

export type DevisModeleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "adresseId_ASC"
  | "adresseId_DESC"
  | "created_ASC"
  | "created_DESC"
  | "deleted_ASC"
  | "deleted_DESC"
  | "modele_ASC"
  | "modele_DESC"
  | "name_ASC"
  | "name_DESC"
  | "structureId_ASC"
  | "structureId_DESC"
  | "texteBas_ASC"
  | "texteBas_DESC"
  | "updated_ASC"
  | "updated_DESC";

export type DocumentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "commentaire_ASC"
  | "commentaire_DESC"
  | "created_ASC"
  | "created_DESC"
  | "dateEmission_ASC"
  | "dateEmission_DESC"
  | "deleted_ASC"
  | "deleted_DESC"
  | "documentTypeId_ASC"
  | "documentTypeId_DESC"
  | "entityId_ASC"
  | "entityId_DESC"
  | "file_ASC"
  | "file_DESC"
  | "insertedId_ASC"
  | "insertedId_DESC"
  | "name_ASC"
  | "name_DESC"
  | "public_ASC"
  | "public_DESC"
  | "structureId_ASC"
  | "structureId_DESC"
  | "updated_ASC"
  | "updated_DESC"
  | "verEdition_ASC"
  | "verEdition_DESC";

export type DocumentTypeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC";

export type EmpInfoOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "compteBancaire_ASC"
  | "compteBancaire_DESC"
  | "created_ASC"
  | "created_DESC"
  | "deleted_ASC"
  | "deleted_DESC"
  | "nbreEnfants_ASC"
  | "nbreEnfants_DESC"
  | "numCimr_ASC"
  | "numCimr_DESC"
  | "numCnss_ASC"
  | "numCnss_DESC"
  | "numMutuelle_ASC"
  | "numMutuelle_DESC"
  | "numPasseport_ASC"
  | "numPasseport_DESC"
  | "situationFamiliale_ASC"
  | "situationFamiliale_DESC"
  | "updated_ASC"
  | "updated_DESC";

export type EmployeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "adresseId_ASC"
  | "adresseId_DESC"
  | "code_ASC"
  | "code_DESC"
  | "created_ASC"
  | "created_DESC"
  | "deleted_ASC"
  | "deleted_DESC"
  | "departmentId_ASC"
  | "departmentId_DESC"
  | "empInfoId_ASC"
  | "empInfoId_DESC"
  | "firstname_ASC"
  | "firstname_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "hireDate_ASC"
  | "hireDate_DESC"
  | "jobId_ASC"
  | "jobId_DESC"
  | "lastname_ASC"
  | "lastname_DESC"
  | "managerId_ASC"
  | "managerId_DESC"
  | "phone1_ASC"
  | "phone1_DESC"
  | "phone2_ASC"
  | "phone2_DESC"
  | "salary_ASC"
  | "salary_DESC"
  | "structureId_ASC"
  | "structureId_DESC"
  | "type_ASC"
  | "type_DESC"
  | "updated_ASC"
  | "updated_DESC";

export type EntityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "addressId_ASC"
  | "addressId_DESC"
  | "created_ASC"
  | "created_DESC"
  | "deleted_ASC"
  | "deleted_DESC"
  | "name_ASC"
  | "name_DESC"
  | "seat_ASC"
  | "seat_DESC"
  | "structureId_ASC"
  | "structureId_DESC"
  | "updated_ASC"
  | "updated_DESC";

export type FileOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "messageId_ASC"
  | "messageId_DESC"
  | "nom_ASC"
  | "nom_DESC";

export type JobOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "created_ASC"
  | "created_DESC"
  | "deleted_ASC"
  | "deleted_DESC"
  | "description_ASC"
  | "description_DESC"
  | "keyword_ASC"
  | "keyword_DESC"
  | "maxSalary_ASC"
  | "maxSalary_DESC"
  | "minSalary_ASC"
  | "minSalary_DESC"
  | "title_ASC"
  | "title_DESC"
  | "updated_ASC"
  | "updated_DESC";

export type LegalTypeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "code_ASC"
  | "code_DESC"
  | "created_ASC"
  | "created_DESC"
  | "name_ASC"
  | "name_DESC";

export type MactionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "date_ASC"
  | "date_DESC"
  | "deleted_ASC"
  | "deleted_DESC"
  | "description_ASC"
  | "description_DESC"
  | "effectuePar_ASC"
  | "effectuePar_DESC"
  | "memberId_ASC"
  | "memberId_DESC"
  | "statut_ASC"
  | "statut_DESC"
  | "titre_ASC"
  | "titre_DESC";

export type MovementOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "created_ASC"
  | "created_DESC"
  | "date_ASC"
  | "date_DESC"
  | "deleted_ASC"
  | "deleted_DESC"
  | "designation_ASC"
  | "designation_DESC"
  | "documentId_ASC"
  | "documentId_DESC"
  | "htTotal_ASC"
  | "htTotal_DESC"
  | "insertedId_ASC"
  | "insertedId_DESC"
  | "price_ASC"
  | "price_DESC"
  | "quantite_ASC"
  | "quantite_DESC"
  | "structureId_ASC"
  | "structureId_DESC"
  | "ttcTotal_ASC"
  | "ttcTotal_DESC"
  | "tvaId_ASC"
  | "tvaId_DESC"
  | "type_ASC"
  | "type_DESC";

export type PersonOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "firstname_ASC"
  | "firstname_DESC"
  | "lastname_ASC"
  | "lastname_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type StructureOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "raison_sociale_ASC"
  | "raison_sociale_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "nom_ASC"
  | "nom_DESC"
  | "prenom_ASC"
  | "prenom_DESC"
  | "password_ASC"
  | "password_DESC"
  | "telephone_ASC"
  | "telephone_DESC"
  | "telephone2_ASC"
  | "telephone2_DESC"
  | "ville_ASC"
  | "ville_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ClientWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface ClientWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  type?: Maybe<Boolean>;
  type_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  person?: Maybe<PersonWhereInput>;
  structure?: Maybe<StructureWhereInput>;
  AND?: Maybe<ClientWhereInput[] | ClientWhereInput>;
  OR?: Maybe<ClientWhereInput[] | ClientWhereInput>;
  NOT?: Maybe<ClientWhereInput[] | ClientWhereInput>;
}

export interface PersonWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  firstname?: Maybe<String>;
  firstname_not?: Maybe<String>;
  firstname_in?: Maybe<String[] | String>;
  firstname_not_in?: Maybe<String[] | String>;
  firstname_lt?: Maybe<String>;
  firstname_lte?: Maybe<String>;
  firstname_gt?: Maybe<String>;
  firstname_gte?: Maybe<String>;
  firstname_contains?: Maybe<String>;
  firstname_not_contains?: Maybe<String>;
  firstname_starts_with?: Maybe<String>;
  firstname_not_starts_with?: Maybe<String>;
  firstname_ends_with?: Maybe<String>;
  firstname_not_ends_with?: Maybe<String>;
  lastname?: Maybe<String>;
  lastname_not?: Maybe<String>;
  lastname_in?: Maybe<String[] | String>;
  lastname_not_in?: Maybe<String[] | String>;
  lastname_lt?: Maybe<String>;
  lastname_lte?: Maybe<String>;
  lastname_gt?: Maybe<String>;
  lastname_gte?: Maybe<String>;
  lastname_contains?: Maybe<String>;
  lastname_not_contains?: Maybe<String>;
  lastname_starts_with?: Maybe<String>;
  lastname_not_starts_with?: Maybe<String>;
  lastname_ends_with?: Maybe<String>;
  lastname_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PersonWhereInput[] | PersonWhereInput>;
  OR?: Maybe<PersonWhereInput[] | PersonWhereInput>;
  NOT?: Maybe<PersonWhereInput[] | PersonWhereInput>;
}

export interface StructureWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  raison_sociale?: Maybe<String>;
  raison_sociale_not?: Maybe<String>;
  raison_sociale_in?: Maybe<String[] | String>;
  raison_sociale_not_in?: Maybe<String[] | String>;
  raison_sociale_lt?: Maybe<String>;
  raison_sociale_lte?: Maybe<String>;
  raison_sociale_gt?: Maybe<String>;
  raison_sociale_gte?: Maybe<String>;
  raison_sociale_contains?: Maybe<String>;
  raison_sociale_not_contains?: Maybe<String>;
  raison_sociale_starts_with?: Maybe<String>;
  raison_sociale_not_starts_with?: Maybe<String>;
  raison_sociale_ends_with?: Maybe<String>;
  raison_sociale_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<StructureWhereInput[] | StructureWhereInput>;
  OR?: Maybe<StructureWhereInput[] | StructureWhereInput>;
  NOT?: Maybe<StructureWhereInput[] | StructureWhereInput>;
}

export type ContactWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface ContactWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  activite?: Maybe<String>;
  activite_not?: Maybe<String>;
  activite_in?: Maybe<String[] | String>;
  activite_not_in?: Maybe<String[] | String>;
  activite_lt?: Maybe<String>;
  activite_lte?: Maybe<String>;
  activite_gt?: Maybe<String>;
  activite_gte?: Maybe<String>;
  activite_contains?: Maybe<String>;
  activite_not_contains?: Maybe<String>;
  activite_starts_with?: Maybe<String>;
  activite_not_starts_with?: Maybe<String>;
  activite_ends_with?: Maybe<String>;
  activite_not_ends_with?: Maybe<String>;
  adresse?: Maybe<String>;
  adresse_not?: Maybe<String>;
  adresse_in?: Maybe<String[] | String>;
  adresse_not_in?: Maybe<String[] | String>;
  adresse_lt?: Maybe<String>;
  adresse_lte?: Maybe<String>;
  adresse_gt?: Maybe<String>;
  adresse_gte?: Maybe<String>;
  adresse_contains?: Maybe<String>;
  adresse_not_contains?: Maybe<String>;
  adresse_starts_with?: Maybe<String>;
  adresse_not_starts_with?: Maybe<String>;
  adresse_ends_with?: Maybe<String>;
  adresse_not_ends_with?: Maybe<String>;
  adresseComplement?: Maybe<String>;
  adresseComplement_not?: Maybe<String>;
  adresseComplement_in?: Maybe<String[] | String>;
  adresseComplement_not_in?: Maybe<String[] | String>;
  adresseComplement_lt?: Maybe<String>;
  adresseComplement_lte?: Maybe<String>;
  adresseComplement_gt?: Maybe<String>;
  adresseComplement_gte?: Maybe<String>;
  adresseComplement_contains?: Maybe<String>;
  adresseComplement_not_contains?: Maybe<String>;
  adresseComplement_starts_with?: Maybe<String>;
  adresseComplement_not_starts_with?: Maybe<String>;
  adresseComplement_ends_with?: Maybe<String>;
  adresseComplement_not_ends_with?: Maybe<String>;
  civilite?: Maybe<Boolean>;
  civilite_not?: Maybe<Boolean>;
  comment?: Maybe<String>;
  comment_not?: Maybe<String>;
  comment_in?: Maybe<String[] | String>;
  comment_not_in?: Maybe<String[] | String>;
  comment_lt?: Maybe<String>;
  comment_lte?: Maybe<String>;
  comment_gt?: Maybe<String>;
  comment_gte?: Maybe<String>;
  comment_contains?: Maybe<String>;
  comment_not_contains?: Maybe<String>;
  comment_starts_with?: Maybe<String>;
  comment_not_starts_with?: Maybe<String>;
  comment_ends_with?: Maybe<String>;
  comment_not_ends_with?: Maybe<String>;
  companyName?: Maybe<String>;
  companyName_not?: Maybe<String>;
  companyName_in?: Maybe<String[] | String>;
  companyName_not_in?: Maybe<String[] | String>;
  companyName_lt?: Maybe<String>;
  companyName_lte?: Maybe<String>;
  companyName_gt?: Maybe<String>;
  companyName_gte?: Maybe<String>;
  companyName_contains?: Maybe<String>;
  companyName_not_contains?: Maybe<String>;
  companyName_starts_with?: Maybe<String>;
  companyName_not_starts_with?: Maybe<String>;
  companyName_ends_with?: Maybe<String>;
  companyName_not_ends_with?: Maybe<String>;
  countryId?: Maybe<Int>;
  countryId_not?: Maybe<Int>;
  countryId_in?: Maybe<Int[] | Int>;
  countryId_not_in?: Maybe<Int[] | Int>;
  countryId_lt?: Maybe<Int>;
  countryId_lte?: Maybe<Int>;
  countryId_gt?: Maybe<Int>;
  countryId_gte?: Maybe<Int>;
  cp?: Maybe<String>;
  cp_not?: Maybe<String>;
  cp_in?: Maybe<String[] | String>;
  cp_not_in?: Maybe<String[] | String>;
  cp_lt?: Maybe<String>;
  cp_lte?: Maybe<String>;
  cp_gt?: Maybe<String>;
  cp_gte?: Maybe<String>;
  cp_contains?: Maybe<String>;
  cp_not_contains?: Maybe<String>;
  cp_starts_with?: Maybe<String>;
  cp_not_starts_with?: Maybe<String>;
  cp_ends_with?: Maybe<String>;
  cp_not_ends_with?: Maybe<String>;
  created?: Maybe<DateTimeInput>;
  created_not?: Maybe<DateTimeInput>;
  created_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_lt?: Maybe<DateTimeInput>;
  created_lte?: Maybe<DateTimeInput>;
  created_gt?: Maybe<DateTimeInput>;
  created_gte?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  insertedId?: Maybe<Int>;
  insertedId_not?: Maybe<Int>;
  insertedId_in?: Maybe<Int[] | Int>;
  insertedId_not_in?: Maybe<Int[] | Int>;
  insertedId_lt?: Maybe<Int>;
  insertedId_lte?: Maybe<Int>;
  insertedId_gt?: Maybe<Int>;
  insertedId_gte?: Maybe<Int>;
  lienSite?: Maybe<String>;
  lienSite_not?: Maybe<String>;
  lienSite_in?: Maybe<String[] | String>;
  lienSite_not_in?: Maybe<String[] | String>;
  lienSite_lt?: Maybe<String>;
  lienSite_lte?: Maybe<String>;
  lienSite_gt?: Maybe<String>;
  lienSite_gte?: Maybe<String>;
  lienSite_contains?: Maybe<String>;
  lienSite_not_contains?: Maybe<String>;
  lienSite_starts_with?: Maybe<String>;
  lienSite_not_starts_with?: Maybe<String>;
  lienSite_ends_with?: Maybe<String>;
  lienSite_not_ends_with?: Maybe<String>;
  nom?: Maybe<String>;
  nom_not?: Maybe<String>;
  nom_in?: Maybe<String[] | String>;
  nom_not_in?: Maybe<String[] | String>;
  nom_lt?: Maybe<String>;
  nom_lte?: Maybe<String>;
  nom_gt?: Maybe<String>;
  nom_gte?: Maybe<String>;
  nom_contains?: Maybe<String>;
  nom_not_contains?: Maybe<String>;
  nom_starts_with?: Maybe<String>;
  nom_not_starts_with?: Maybe<String>;
  nom_ends_with?: Maybe<String>;
  nom_not_ends_with?: Maybe<String>;
  prenom?: Maybe<String>;
  prenom_not?: Maybe<String>;
  prenom_in?: Maybe<String[] | String>;
  prenom_not_in?: Maybe<String[] | String>;
  prenom_lt?: Maybe<String>;
  prenom_lte?: Maybe<String>;
  prenom_gt?: Maybe<String>;
  prenom_gte?: Maybe<String>;
  prenom_contains?: Maybe<String>;
  prenom_not_contains?: Maybe<String>;
  prenom_starts_with?: Maybe<String>;
  prenom_not_starts_with?: Maybe<String>;
  prenom_ends_with?: Maybe<String>;
  prenom_not_ends_with?: Maybe<String>;
  structureId?: Maybe<Int>;
  structureId_not?: Maybe<Int>;
  structureId_in?: Maybe<Int[] | Int>;
  structureId_not_in?: Maybe<Int[] | Int>;
  structureId_lt?: Maybe<Int>;
  structureId_lte?: Maybe<Int>;
  structureId_gt?: Maybe<Int>;
  structureId_gte?: Maybe<Int>;
  tel1?: Maybe<String>;
  tel1_not?: Maybe<String>;
  tel1_in?: Maybe<String[] | String>;
  tel1_not_in?: Maybe<String[] | String>;
  tel1_lt?: Maybe<String>;
  tel1_lte?: Maybe<String>;
  tel1_gt?: Maybe<String>;
  tel1_gte?: Maybe<String>;
  tel1_contains?: Maybe<String>;
  tel1_not_contains?: Maybe<String>;
  tel1_starts_with?: Maybe<String>;
  tel1_not_starts_with?: Maybe<String>;
  tel1_ends_with?: Maybe<String>;
  tel1_not_ends_with?: Maybe<String>;
  tel2?: Maybe<String>;
  tel2_not?: Maybe<String>;
  tel2_in?: Maybe<String[] | String>;
  tel2_not_in?: Maybe<String[] | String>;
  tel2_lt?: Maybe<String>;
  tel2_lte?: Maybe<String>;
  tel2_gt?: Maybe<String>;
  tel2_gte?: Maybe<String>;
  tel2_contains?: Maybe<String>;
  tel2_not_contains?: Maybe<String>;
  tel2_starts_with?: Maybe<String>;
  tel2_not_starts_with?: Maybe<String>;
  tel2_ends_with?: Maybe<String>;
  tel2_not_ends_with?: Maybe<String>;
  ville?: Maybe<String>;
  ville_not?: Maybe<String>;
  ville_in?: Maybe<String[] | String>;
  ville_not_in?: Maybe<String[] | String>;
  ville_lt?: Maybe<String>;
  ville_lte?: Maybe<String>;
  ville_gt?: Maybe<String>;
  ville_gte?: Maybe<String>;
  ville_contains?: Maybe<String>;
  ville_not_contains?: Maybe<String>;
  ville_starts_with?: Maybe<String>;
  ville_not_starts_with?: Maybe<String>;
  ville_ends_with?: Maybe<String>;
  ville_not_ends_with?: Maybe<String>;
  AND?: Maybe<ContactWhereInput[] | ContactWhereInput>;
  OR?: Maybe<ContactWhereInput[] | ContactWhereInput>;
  NOT?: Maybe<ContactWhereInput[] | ContactWhereInput>;
}

export type CountryWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface CountryWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  code?: Maybe<String>;
  code_not?: Maybe<String>;
  code_in?: Maybe<String[] | String>;
  code_not_in?: Maybe<String[] | String>;
  code_lt?: Maybe<String>;
  code_lte?: Maybe<String>;
  code_gt?: Maybe<String>;
  code_gte?: Maybe<String>;
  code_contains?: Maybe<String>;
  code_not_contains?: Maybe<String>;
  code_starts_with?: Maybe<String>;
  code_not_starts_with?: Maybe<String>;
  code_ends_with?: Maybe<String>;
  code_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  ordre?: Maybe<Int>;
  ordre_not?: Maybe<Int>;
  ordre_in?: Maybe<Int[] | Int>;
  ordre_not_in?: Maybe<Int[] | Int>;
  ordre_lt?: Maybe<Int>;
  ordre_lte?: Maybe<Int>;
  ordre_gt?: Maybe<Int>;
  ordre_gte?: Maybe<Int>;
  AND?: Maybe<CountryWhereInput[] | CountryWhereInput>;
  OR?: Maybe<CountryWhereInput[] | CountryWhereInput>;
  NOT?: Maybe<CountryWhereInput[] | CountryWhereInput>;
}

export type DepartmentWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface DepartmentWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  created?: Maybe<DateTimeInput>;
  created_not?: Maybe<DateTimeInput>;
  created_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_lt?: Maybe<DateTimeInput>;
  created_lte?: Maybe<DateTimeInput>;
  created_gt?: Maybe<DateTimeInput>;
  created_gte?: Maybe<DateTimeInput>;
  deleted?: Maybe<Boolean>;
  deleted_not?: Maybe<Boolean>;
  location?: Maybe<String>;
  location_not?: Maybe<String>;
  location_in?: Maybe<String[] | String>;
  location_not_in?: Maybe<String[] | String>;
  location_lt?: Maybe<String>;
  location_lte?: Maybe<String>;
  location_gt?: Maybe<String>;
  location_gte?: Maybe<String>;
  location_contains?: Maybe<String>;
  location_not_contains?: Maybe<String>;
  location_starts_with?: Maybe<String>;
  location_not_starts_with?: Maybe<String>;
  location_ends_with?: Maybe<String>;
  location_not_ends_with?: Maybe<String>;
  managerId?: Maybe<Int>;
  managerId_not?: Maybe<Int>;
  managerId_in?: Maybe<Int[] | Int>;
  managerId_not_in?: Maybe<Int[] | Int>;
  managerId_lt?: Maybe<Int>;
  managerId_lte?: Maybe<Int>;
  managerId_gt?: Maybe<Int>;
  managerId_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  structureId?: Maybe<Int>;
  structureId_not?: Maybe<Int>;
  structureId_in?: Maybe<Int[] | Int>;
  structureId_not_in?: Maybe<Int[] | Int>;
  structureId_lt?: Maybe<Int>;
  structureId_lte?: Maybe<Int>;
  structureId_gt?: Maybe<Int>;
  structureId_gte?: Maybe<Int>;
  updated?: Maybe<DateTimeInput>;
  updated_not?: Maybe<DateTimeInput>;
  updated_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_lt?: Maybe<DateTimeInput>;
  updated_lte?: Maybe<DateTimeInput>;
  updated_gt?: Maybe<DateTimeInput>;
  updated_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<DepartmentWhereInput[] | DepartmentWhereInput>;
  OR?: Maybe<DepartmentWhereInput[] | DepartmentWhereInput>;
  NOT?: Maybe<DepartmentWhereInput[] | DepartmentWhereInput>;
}

export type DevisModeleWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface DevisModeleWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  adresseId?: Maybe<Int>;
  adresseId_not?: Maybe<Int>;
  adresseId_in?: Maybe<Int[] | Int>;
  adresseId_not_in?: Maybe<Int[] | Int>;
  adresseId_lt?: Maybe<Int>;
  adresseId_lte?: Maybe<Int>;
  adresseId_gt?: Maybe<Int>;
  adresseId_gte?: Maybe<Int>;
  created?: Maybe<DateTimeInput>;
  created_not?: Maybe<DateTimeInput>;
  created_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_lt?: Maybe<DateTimeInput>;
  created_lte?: Maybe<DateTimeInput>;
  created_gt?: Maybe<DateTimeInput>;
  created_gte?: Maybe<DateTimeInput>;
  deleted?: Maybe<Boolean>;
  deleted_not?: Maybe<Boolean>;
  modele?: Maybe<String>;
  modele_not?: Maybe<String>;
  modele_in?: Maybe<String[] | String>;
  modele_not_in?: Maybe<String[] | String>;
  modele_lt?: Maybe<String>;
  modele_lte?: Maybe<String>;
  modele_gt?: Maybe<String>;
  modele_gte?: Maybe<String>;
  modele_contains?: Maybe<String>;
  modele_not_contains?: Maybe<String>;
  modele_starts_with?: Maybe<String>;
  modele_not_starts_with?: Maybe<String>;
  modele_ends_with?: Maybe<String>;
  modele_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  structureId?: Maybe<Int>;
  structureId_not?: Maybe<Int>;
  structureId_in?: Maybe<Int[] | Int>;
  structureId_not_in?: Maybe<Int[] | Int>;
  structureId_lt?: Maybe<Int>;
  structureId_lte?: Maybe<Int>;
  structureId_gt?: Maybe<Int>;
  structureId_gte?: Maybe<Int>;
  texteBas?: Maybe<String>;
  texteBas_not?: Maybe<String>;
  texteBas_in?: Maybe<String[] | String>;
  texteBas_not_in?: Maybe<String[] | String>;
  texteBas_lt?: Maybe<String>;
  texteBas_lte?: Maybe<String>;
  texteBas_gt?: Maybe<String>;
  texteBas_gte?: Maybe<String>;
  texteBas_contains?: Maybe<String>;
  texteBas_not_contains?: Maybe<String>;
  texteBas_starts_with?: Maybe<String>;
  texteBas_not_starts_with?: Maybe<String>;
  texteBas_ends_with?: Maybe<String>;
  texteBas_not_ends_with?: Maybe<String>;
  updated?: Maybe<DateTimeInput>;
  updated_not?: Maybe<DateTimeInput>;
  updated_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_lt?: Maybe<DateTimeInput>;
  updated_lte?: Maybe<DateTimeInput>;
  updated_gt?: Maybe<DateTimeInput>;
  updated_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<DevisModeleWhereInput[] | DevisModeleWhereInput>;
  OR?: Maybe<DevisModeleWhereInput[] | DevisModeleWhereInput>;
  NOT?: Maybe<DevisModeleWhereInput[] | DevisModeleWhereInput>;
}

export type DocumentWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface DocumentWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  commentaire?: Maybe<String>;
  commentaire_not?: Maybe<String>;
  commentaire_in?: Maybe<String[] | String>;
  commentaire_not_in?: Maybe<String[] | String>;
  commentaire_lt?: Maybe<String>;
  commentaire_lte?: Maybe<String>;
  commentaire_gt?: Maybe<String>;
  commentaire_gte?: Maybe<String>;
  commentaire_contains?: Maybe<String>;
  commentaire_not_contains?: Maybe<String>;
  commentaire_starts_with?: Maybe<String>;
  commentaire_not_starts_with?: Maybe<String>;
  commentaire_ends_with?: Maybe<String>;
  commentaire_not_ends_with?: Maybe<String>;
  created?: Maybe<DateTimeInput>;
  created_not?: Maybe<DateTimeInput>;
  created_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_lt?: Maybe<DateTimeInput>;
  created_lte?: Maybe<DateTimeInput>;
  created_gt?: Maybe<DateTimeInput>;
  created_gte?: Maybe<DateTimeInput>;
  dateEmission?: Maybe<DateTimeInput>;
  dateEmission_not?: Maybe<DateTimeInput>;
  dateEmission_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateEmission_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateEmission_lt?: Maybe<DateTimeInput>;
  dateEmission_lte?: Maybe<DateTimeInput>;
  dateEmission_gt?: Maybe<DateTimeInput>;
  dateEmission_gte?: Maybe<DateTimeInput>;
  deleted?: Maybe<Boolean>;
  deleted_not?: Maybe<Boolean>;
  documentTypeId?: Maybe<Int>;
  documentTypeId_not?: Maybe<Int>;
  documentTypeId_in?: Maybe<Int[] | Int>;
  documentTypeId_not_in?: Maybe<Int[] | Int>;
  documentTypeId_lt?: Maybe<Int>;
  documentTypeId_lte?: Maybe<Int>;
  documentTypeId_gt?: Maybe<Int>;
  documentTypeId_gte?: Maybe<Int>;
  entityId?: Maybe<Int>;
  entityId_not?: Maybe<Int>;
  entityId_in?: Maybe<Int[] | Int>;
  entityId_not_in?: Maybe<Int[] | Int>;
  entityId_lt?: Maybe<Int>;
  entityId_lte?: Maybe<Int>;
  entityId_gt?: Maybe<Int>;
  entityId_gte?: Maybe<Int>;
  file?: Maybe<String>;
  file_not?: Maybe<String>;
  file_in?: Maybe<String[] | String>;
  file_not_in?: Maybe<String[] | String>;
  file_lt?: Maybe<String>;
  file_lte?: Maybe<String>;
  file_gt?: Maybe<String>;
  file_gte?: Maybe<String>;
  file_contains?: Maybe<String>;
  file_not_contains?: Maybe<String>;
  file_starts_with?: Maybe<String>;
  file_not_starts_with?: Maybe<String>;
  file_ends_with?: Maybe<String>;
  file_not_ends_with?: Maybe<String>;
  insertedId?: Maybe<Int>;
  insertedId_not?: Maybe<Int>;
  insertedId_in?: Maybe<Int[] | Int>;
  insertedId_not_in?: Maybe<Int[] | Int>;
  insertedId_lt?: Maybe<Int>;
  insertedId_lte?: Maybe<Int>;
  insertedId_gt?: Maybe<Int>;
  insertedId_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  public?: Maybe<Boolean>;
  public_not?: Maybe<Boolean>;
  structureId?: Maybe<Int>;
  structureId_not?: Maybe<Int>;
  structureId_in?: Maybe<Int[] | Int>;
  structureId_not_in?: Maybe<Int[] | Int>;
  structureId_lt?: Maybe<Int>;
  structureId_lte?: Maybe<Int>;
  structureId_gt?: Maybe<Int>;
  structureId_gte?: Maybe<Int>;
  updated?: Maybe<DateTimeInput>;
  updated_not?: Maybe<DateTimeInput>;
  updated_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_lt?: Maybe<DateTimeInput>;
  updated_lte?: Maybe<DateTimeInput>;
  updated_gt?: Maybe<DateTimeInput>;
  updated_gte?: Maybe<DateTimeInput>;
  verEdition?: Maybe<Boolean>;
  verEdition_not?: Maybe<Boolean>;
  AND?: Maybe<DocumentWhereInput[] | DocumentWhereInput>;
  OR?: Maybe<DocumentWhereInput[] | DocumentWhereInput>;
  NOT?: Maybe<DocumentWhereInput[] | DocumentWhereInput>;
}

export type DocumentTypeWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface DocumentTypeWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  AND?: Maybe<DocumentTypeWhereInput[] | DocumentTypeWhereInput>;
  OR?: Maybe<DocumentTypeWhereInput[] | DocumentTypeWhereInput>;
  NOT?: Maybe<DocumentTypeWhereInput[] | DocumentTypeWhereInput>;
}

export type EmpInfoWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface EmpInfoWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  compteBancaire?: Maybe<String>;
  compteBancaire_not?: Maybe<String>;
  compteBancaire_in?: Maybe<String[] | String>;
  compteBancaire_not_in?: Maybe<String[] | String>;
  compteBancaire_lt?: Maybe<String>;
  compteBancaire_lte?: Maybe<String>;
  compteBancaire_gt?: Maybe<String>;
  compteBancaire_gte?: Maybe<String>;
  compteBancaire_contains?: Maybe<String>;
  compteBancaire_not_contains?: Maybe<String>;
  compteBancaire_starts_with?: Maybe<String>;
  compteBancaire_not_starts_with?: Maybe<String>;
  compteBancaire_ends_with?: Maybe<String>;
  compteBancaire_not_ends_with?: Maybe<String>;
  created?: Maybe<DateTimeInput>;
  created_not?: Maybe<DateTimeInput>;
  created_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_lt?: Maybe<DateTimeInput>;
  created_lte?: Maybe<DateTimeInput>;
  created_gt?: Maybe<DateTimeInput>;
  created_gte?: Maybe<DateTimeInput>;
  deleted?: Maybe<Boolean>;
  deleted_not?: Maybe<Boolean>;
  nbreEnfants?: Maybe<Int>;
  nbreEnfants_not?: Maybe<Int>;
  nbreEnfants_in?: Maybe<Int[] | Int>;
  nbreEnfants_not_in?: Maybe<Int[] | Int>;
  nbreEnfants_lt?: Maybe<Int>;
  nbreEnfants_lte?: Maybe<Int>;
  nbreEnfants_gt?: Maybe<Int>;
  nbreEnfants_gte?: Maybe<Int>;
  numCimr?: Maybe<String>;
  numCimr_not?: Maybe<String>;
  numCimr_in?: Maybe<String[] | String>;
  numCimr_not_in?: Maybe<String[] | String>;
  numCimr_lt?: Maybe<String>;
  numCimr_lte?: Maybe<String>;
  numCimr_gt?: Maybe<String>;
  numCimr_gte?: Maybe<String>;
  numCimr_contains?: Maybe<String>;
  numCimr_not_contains?: Maybe<String>;
  numCimr_starts_with?: Maybe<String>;
  numCimr_not_starts_with?: Maybe<String>;
  numCimr_ends_with?: Maybe<String>;
  numCimr_not_ends_with?: Maybe<String>;
  numCnss?: Maybe<String>;
  numCnss_not?: Maybe<String>;
  numCnss_in?: Maybe<String[] | String>;
  numCnss_not_in?: Maybe<String[] | String>;
  numCnss_lt?: Maybe<String>;
  numCnss_lte?: Maybe<String>;
  numCnss_gt?: Maybe<String>;
  numCnss_gte?: Maybe<String>;
  numCnss_contains?: Maybe<String>;
  numCnss_not_contains?: Maybe<String>;
  numCnss_starts_with?: Maybe<String>;
  numCnss_not_starts_with?: Maybe<String>;
  numCnss_ends_with?: Maybe<String>;
  numCnss_not_ends_with?: Maybe<String>;
  numMutuelle?: Maybe<String>;
  numMutuelle_not?: Maybe<String>;
  numMutuelle_in?: Maybe<String[] | String>;
  numMutuelle_not_in?: Maybe<String[] | String>;
  numMutuelle_lt?: Maybe<String>;
  numMutuelle_lte?: Maybe<String>;
  numMutuelle_gt?: Maybe<String>;
  numMutuelle_gte?: Maybe<String>;
  numMutuelle_contains?: Maybe<String>;
  numMutuelle_not_contains?: Maybe<String>;
  numMutuelle_starts_with?: Maybe<String>;
  numMutuelle_not_starts_with?: Maybe<String>;
  numMutuelle_ends_with?: Maybe<String>;
  numMutuelle_not_ends_with?: Maybe<String>;
  numPasseport?: Maybe<String>;
  numPasseport_not?: Maybe<String>;
  numPasseport_in?: Maybe<String[] | String>;
  numPasseport_not_in?: Maybe<String[] | String>;
  numPasseport_lt?: Maybe<String>;
  numPasseport_lte?: Maybe<String>;
  numPasseport_gt?: Maybe<String>;
  numPasseport_gte?: Maybe<String>;
  numPasseport_contains?: Maybe<String>;
  numPasseport_not_contains?: Maybe<String>;
  numPasseport_starts_with?: Maybe<String>;
  numPasseport_not_starts_with?: Maybe<String>;
  numPasseport_ends_with?: Maybe<String>;
  numPasseport_not_ends_with?: Maybe<String>;
  situationFamiliale?: Maybe<Int>;
  situationFamiliale_not?: Maybe<Int>;
  situationFamiliale_in?: Maybe<Int[] | Int>;
  situationFamiliale_not_in?: Maybe<Int[] | Int>;
  situationFamiliale_lt?: Maybe<Int>;
  situationFamiliale_lte?: Maybe<Int>;
  situationFamiliale_gt?: Maybe<Int>;
  situationFamiliale_gte?: Maybe<Int>;
  updated?: Maybe<DateTimeInput>;
  updated_not?: Maybe<DateTimeInput>;
  updated_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_lt?: Maybe<DateTimeInput>;
  updated_lte?: Maybe<DateTimeInput>;
  updated_gt?: Maybe<DateTimeInput>;
  updated_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<EmpInfoWhereInput[] | EmpInfoWhereInput>;
  OR?: Maybe<EmpInfoWhereInput[] | EmpInfoWhereInput>;
  NOT?: Maybe<EmpInfoWhereInput[] | EmpInfoWhereInput>;
}

export type EmployeWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface EmployeWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  adresseId?: Maybe<Int>;
  adresseId_not?: Maybe<Int>;
  adresseId_in?: Maybe<Int[] | Int>;
  adresseId_not_in?: Maybe<Int[] | Int>;
  adresseId_lt?: Maybe<Int>;
  adresseId_lte?: Maybe<Int>;
  adresseId_gt?: Maybe<Int>;
  adresseId_gte?: Maybe<Int>;
  code?: Maybe<String>;
  code_not?: Maybe<String>;
  code_in?: Maybe<String[] | String>;
  code_not_in?: Maybe<String[] | String>;
  code_lt?: Maybe<String>;
  code_lte?: Maybe<String>;
  code_gt?: Maybe<String>;
  code_gte?: Maybe<String>;
  code_contains?: Maybe<String>;
  code_not_contains?: Maybe<String>;
  code_starts_with?: Maybe<String>;
  code_not_starts_with?: Maybe<String>;
  code_ends_with?: Maybe<String>;
  code_not_ends_with?: Maybe<String>;
  created?: Maybe<DateTimeInput>;
  created_not?: Maybe<DateTimeInput>;
  created_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_lt?: Maybe<DateTimeInput>;
  created_lte?: Maybe<DateTimeInput>;
  created_gt?: Maybe<DateTimeInput>;
  created_gte?: Maybe<DateTimeInput>;
  deleted?: Maybe<Boolean>;
  deleted_not?: Maybe<Boolean>;
  departmentId?: Maybe<Int>;
  departmentId_not?: Maybe<Int>;
  departmentId_in?: Maybe<Int[] | Int>;
  departmentId_not_in?: Maybe<Int[] | Int>;
  departmentId_lt?: Maybe<Int>;
  departmentId_lte?: Maybe<Int>;
  departmentId_gt?: Maybe<Int>;
  departmentId_gte?: Maybe<Int>;
  empInfoId?: Maybe<Int>;
  empInfoId_not?: Maybe<Int>;
  empInfoId_in?: Maybe<Int[] | Int>;
  empInfoId_not_in?: Maybe<Int[] | Int>;
  empInfoId_lt?: Maybe<Int>;
  empInfoId_lte?: Maybe<Int>;
  empInfoId_gt?: Maybe<Int>;
  empInfoId_gte?: Maybe<Int>;
  firstname?: Maybe<String>;
  firstname_not?: Maybe<String>;
  firstname_in?: Maybe<String[] | String>;
  firstname_not_in?: Maybe<String[] | String>;
  firstname_lt?: Maybe<String>;
  firstname_lte?: Maybe<String>;
  firstname_gt?: Maybe<String>;
  firstname_gte?: Maybe<String>;
  firstname_contains?: Maybe<String>;
  firstname_not_contains?: Maybe<String>;
  firstname_starts_with?: Maybe<String>;
  firstname_not_starts_with?: Maybe<String>;
  firstname_ends_with?: Maybe<String>;
  firstname_not_ends_with?: Maybe<String>;
  gender?: Maybe<Int>;
  gender_not?: Maybe<Int>;
  gender_in?: Maybe<Int[] | Int>;
  gender_not_in?: Maybe<Int[] | Int>;
  gender_lt?: Maybe<Int>;
  gender_lte?: Maybe<Int>;
  gender_gt?: Maybe<Int>;
  gender_gte?: Maybe<Int>;
  hireDate?: Maybe<DateTimeInput>;
  hireDate_not?: Maybe<DateTimeInput>;
  hireDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  hireDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  hireDate_lt?: Maybe<DateTimeInput>;
  hireDate_lte?: Maybe<DateTimeInput>;
  hireDate_gt?: Maybe<DateTimeInput>;
  hireDate_gte?: Maybe<DateTimeInput>;
  jobId?: Maybe<Int>;
  jobId_not?: Maybe<Int>;
  jobId_in?: Maybe<Int[] | Int>;
  jobId_not_in?: Maybe<Int[] | Int>;
  jobId_lt?: Maybe<Int>;
  jobId_lte?: Maybe<Int>;
  jobId_gt?: Maybe<Int>;
  jobId_gte?: Maybe<Int>;
  lastname?: Maybe<String>;
  lastname_not?: Maybe<String>;
  lastname_in?: Maybe<String[] | String>;
  lastname_not_in?: Maybe<String[] | String>;
  lastname_lt?: Maybe<String>;
  lastname_lte?: Maybe<String>;
  lastname_gt?: Maybe<String>;
  lastname_gte?: Maybe<String>;
  lastname_contains?: Maybe<String>;
  lastname_not_contains?: Maybe<String>;
  lastname_starts_with?: Maybe<String>;
  lastname_not_starts_with?: Maybe<String>;
  lastname_ends_with?: Maybe<String>;
  lastname_not_ends_with?: Maybe<String>;
  managerId?: Maybe<Int>;
  managerId_not?: Maybe<Int>;
  managerId_in?: Maybe<Int[] | Int>;
  managerId_not_in?: Maybe<Int[] | Int>;
  managerId_lt?: Maybe<Int>;
  managerId_lte?: Maybe<Int>;
  managerId_gt?: Maybe<Int>;
  managerId_gte?: Maybe<Int>;
  phone1?: Maybe<String>;
  phone1_not?: Maybe<String>;
  phone1_in?: Maybe<String[] | String>;
  phone1_not_in?: Maybe<String[] | String>;
  phone1_lt?: Maybe<String>;
  phone1_lte?: Maybe<String>;
  phone1_gt?: Maybe<String>;
  phone1_gte?: Maybe<String>;
  phone1_contains?: Maybe<String>;
  phone1_not_contains?: Maybe<String>;
  phone1_starts_with?: Maybe<String>;
  phone1_not_starts_with?: Maybe<String>;
  phone1_ends_with?: Maybe<String>;
  phone1_not_ends_with?: Maybe<String>;
  phone2?: Maybe<String>;
  phone2_not?: Maybe<String>;
  phone2_in?: Maybe<String[] | String>;
  phone2_not_in?: Maybe<String[] | String>;
  phone2_lt?: Maybe<String>;
  phone2_lte?: Maybe<String>;
  phone2_gt?: Maybe<String>;
  phone2_gte?: Maybe<String>;
  phone2_contains?: Maybe<String>;
  phone2_not_contains?: Maybe<String>;
  phone2_starts_with?: Maybe<String>;
  phone2_not_starts_with?: Maybe<String>;
  phone2_ends_with?: Maybe<String>;
  phone2_not_ends_with?: Maybe<String>;
  salary?: Maybe<Float>;
  salary_not?: Maybe<Float>;
  salary_in?: Maybe<Float[] | Float>;
  salary_not_in?: Maybe<Float[] | Float>;
  salary_lt?: Maybe<Float>;
  salary_lte?: Maybe<Float>;
  salary_gt?: Maybe<Float>;
  salary_gte?: Maybe<Float>;
  structureId?: Maybe<Int>;
  structureId_not?: Maybe<Int>;
  structureId_in?: Maybe<Int[] | Int>;
  structureId_not_in?: Maybe<Int[] | Int>;
  structureId_lt?: Maybe<Int>;
  structureId_lte?: Maybe<Int>;
  structureId_gt?: Maybe<Int>;
  structureId_gte?: Maybe<Int>;
  type?: Maybe<Boolean>;
  type_not?: Maybe<Boolean>;
  updated?: Maybe<DateTimeInput>;
  updated_not?: Maybe<DateTimeInput>;
  updated_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_lt?: Maybe<DateTimeInput>;
  updated_lte?: Maybe<DateTimeInput>;
  updated_gt?: Maybe<DateTimeInput>;
  updated_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<EmployeWhereInput[] | EmployeWhereInput>;
  OR?: Maybe<EmployeWhereInput[] | EmployeWhereInput>;
  NOT?: Maybe<EmployeWhereInput[] | EmployeWhereInput>;
}

export type EntityWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface EntityWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  addressId?: Maybe<Int>;
  addressId_not?: Maybe<Int>;
  addressId_in?: Maybe<Int[] | Int>;
  addressId_not_in?: Maybe<Int[] | Int>;
  addressId_lt?: Maybe<Int>;
  addressId_lte?: Maybe<Int>;
  addressId_gt?: Maybe<Int>;
  addressId_gte?: Maybe<Int>;
  created?: Maybe<DateTimeInput>;
  created_not?: Maybe<DateTimeInput>;
  created_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_lt?: Maybe<DateTimeInput>;
  created_lte?: Maybe<DateTimeInput>;
  created_gt?: Maybe<DateTimeInput>;
  created_gte?: Maybe<DateTimeInput>;
  deleted?: Maybe<Boolean>;
  deleted_not?: Maybe<Boolean>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  seat?: Maybe<String>;
  seat_not?: Maybe<String>;
  seat_in?: Maybe<String[] | String>;
  seat_not_in?: Maybe<String[] | String>;
  seat_lt?: Maybe<String>;
  seat_lte?: Maybe<String>;
  seat_gt?: Maybe<String>;
  seat_gte?: Maybe<String>;
  seat_contains?: Maybe<String>;
  seat_not_contains?: Maybe<String>;
  seat_starts_with?: Maybe<String>;
  seat_not_starts_with?: Maybe<String>;
  seat_ends_with?: Maybe<String>;
  seat_not_ends_with?: Maybe<String>;
  structureId?: Maybe<Int>;
  structureId_not?: Maybe<Int>;
  structureId_in?: Maybe<Int[] | Int>;
  structureId_not_in?: Maybe<Int[] | Int>;
  structureId_lt?: Maybe<Int>;
  structureId_lte?: Maybe<Int>;
  structureId_gt?: Maybe<Int>;
  structureId_gte?: Maybe<Int>;
  updated?: Maybe<DateTimeInput>;
  updated_not?: Maybe<DateTimeInput>;
  updated_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_lt?: Maybe<DateTimeInput>;
  updated_lte?: Maybe<DateTimeInput>;
  updated_gt?: Maybe<DateTimeInput>;
  updated_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<EntityWhereInput[] | EntityWhereInput>;
  OR?: Maybe<EntityWhereInput[] | EntityWhereInput>;
  NOT?: Maybe<EntityWhereInput[] | EntityWhereInput>;
}

export type FileWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface FileWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  messageId?: Maybe<Int>;
  messageId_not?: Maybe<Int>;
  messageId_in?: Maybe<Int[] | Int>;
  messageId_not_in?: Maybe<Int[] | Int>;
  messageId_lt?: Maybe<Int>;
  messageId_lte?: Maybe<Int>;
  messageId_gt?: Maybe<Int>;
  messageId_gte?: Maybe<Int>;
  nom?: Maybe<String>;
  nom_not?: Maybe<String>;
  nom_in?: Maybe<String[] | String>;
  nom_not_in?: Maybe<String[] | String>;
  nom_lt?: Maybe<String>;
  nom_lte?: Maybe<String>;
  nom_gt?: Maybe<String>;
  nom_gte?: Maybe<String>;
  nom_contains?: Maybe<String>;
  nom_not_contains?: Maybe<String>;
  nom_starts_with?: Maybe<String>;
  nom_not_starts_with?: Maybe<String>;
  nom_ends_with?: Maybe<String>;
  nom_not_ends_with?: Maybe<String>;
  AND?: Maybe<FileWhereInput[] | FileWhereInput>;
  OR?: Maybe<FileWhereInput[] | FileWhereInput>;
  NOT?: Maybe<FileWhereInput[] | FileWhereInput>;
}

export type JobWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface JobWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  created?: Maybe<DateTimeInput>;
  created_not?: Maybe<DateTimeInput>;
  created_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_lt?: Maybe<DateTimeInput>;
  created_lte?: Maybe<DateTimeInput>;
  created_gt?: Maybe<DateTimeInput>;
  created_gte?: Maybe<DateTimeInput>;
  deleted?: Maybe<Boolean>;
  deleted_not?: Maybe<Boolean>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  keyword?: Maybe<String>;
  keyword_not?: Maybe<String>;
  keyword_in?: Maybe<String[] | String>;
  keyword_not_in?: Maybe<String[] | String>;
  keyword_lt?: Maybe<String>;
  keyword_lte?: Maybe<String>;
  keyword_gt?: Maybe<String>;
  keyword_gte?: Maybe<String>;
  keyword_contains?: Maybe<String>;
  keyword_not_contains?: Maybe<String>;
  keyword_starts_with?: Maybe<String>;
  keyword_not_starts_with?: Maybe<String>;
  keyword_ends_with?: Maybe<String>;
  keyword_not_ends_with?: Maybe<String>;
  maxSalary?: Maybe<Float>;
  maxSalary_not?: Maybe<Float>;
  maxSalary_in?: Maybe<Float[] | Float>;
  maxSalary_not_in?: Maybe<Float[] | Float>;
  maxSalary_lt?: Maybe<Float>;
  maxSalary_lte?: Maybe<Float>;
  maxSalary_gt?: Maybe<Float>;
  maxSalary_gte?: Maybe<Float>;
  minSalary?: Maybe<Float>;
  minSalary_not?: Maybe<Float>;
  minSalary_in?: Maybe<Float[] | Float>;
  minSalary_not_in?: Maybe<Float[] | Float>;
  minSalary_lt?: Maybe<Float>;
  minSalary_lte?: Maybe<Float>;
  minSalary_gt?: Maybe<Float>;
  minSalary_gte?: Maybe<Float>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  updated?: Maybe<DateTimeInput>;
  updated_not?: Maybe<DateTimeInput>;
  updated_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_lt?: Maybe<DateTimeInput>;
  updated_lte?: Maybe<DateTimeInput>;
  updated_gt?: Maybe<DateTimeInput>;
  updated_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<JobWhereInput[] | JobWhereInput>;
  OR?: Maybe<JobWhereInput[] | JobWhereInput>;
  NOT?: Maybe<JobWhereInput[] | JobWhereInput>;
}

export type LegalTypeWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface LegalTypeWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  code?: Maybe<String>;
  code_not?: Maybe<String>;
  code_in?: Maybe<String[] | String>;
  code_not_in?: Maybe<String[] | String>;
  code_lt?: Maybe<String>;
  code_lte?: Maybe<String>;
  code_gt?: Maybe<String>;
  code_gte?: Maybe<String>;
  code_contains?: Maybe<String>;
  code_not_contains?: Maybe<String>;
  code_starts_with?: Maybe<String>;
  code_not_starts_with?: Maybe<String>;
  code_ends_with?: Maybe<String>;
  code_not_ends_with?: Maybe<String>;
  created?: Maybe<DateTimeInput>;
  created_not?: Maybe<DateTimeInput>;
  created_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_lt?: Maybe<DateTimeInput>;
  created_lte?: Maybe<DateTimeInput>;
  created_gt?: Maybe<DateTimeInput>;
  created_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<LegalTypeWhereInput[] | LegalTypeWhereInput>;
  OR?: Maybe<LegalTypeWhereInput[] | LegalTypeWhereInput>;
  NOT?: Maybe<LegalTypeWhereInput[] | LegalTypeWhereInput>;
}

export type MactionWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface MactionWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  deleted?: Maybe<Boolean>;
  deleted_not?: Maybe<Boolean>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  effectuePar?: Maybe<String>;
  effectuePar_not?: Maybe<String>;
  effectuePar_in?: Maybe<String[] | String>;
  effectuePar_not_in?: Maybe<String[] | String>;
  effectuePar_lt?: Maybe<String>;
  effectuePar_lte?: Maybe<String>;
  effectuePar_gt?: Maybe<String>;
  effectuePar_gte?: Maybe<String>;
  effectuePar_contains?: Maybe<String>;
  effectuePar_not_contains?: Maybe<String>;
  effectuePar_starts_with?: Maybe<String>;
  effectuePar_not_starts_with?: Maybe<String>;
  effectuePar_ends_with?: Maybe<String>;
  effectuePar_not_ends_with?: Maybe<String>;
  memberId?: Maybe<Int>;
  memberId_not?: Maybe<Int>;
  memberId_in?: Maybe<Int[] | Int>;
  memberId_not_in?: Maybe<Int[] | Int>;
  memberId_lt?: Maybe<Int>;
  memberId_lte?: Maybe<Int>;
  memberId_gt?: Maybe<Int>;
  memberId_gte?: Maybe<Int>;
  statut?: Maybe<Int>;
  statut_not?: Maybe<Int>;
  statut_in?: Maybe<Int[] | Int>;
  statut_not_in?: Maybe<Int[] | Int>;
  statut_lt?: Maybe<Int>;
  statut_lte?: Maybe<Int>;
  statut_gt?: Maybe<Int>;
  statut_gte?: Maybe<Int>;
  titre?: Maybe<String>;
  titre_not?: Maybe<String>;
  titre_in?: Maybe<String[] | String>;
  titre_not_in?: Maybe<String[] | String>;
  titre_lt?: Maybe<String>;
  titre_lte?: Maybe<String>;
  titre_gt?: Maybe<String>;
  titre_gte?: Maybe<String>;
  titre_contains?: Maybe<String>;
  titre_not_contains?: Maybe<String>;
  titre_starts_with?: Maybe<String>;
  titre_not_starts_with?: Maybe<String>;
  titre_ends_with?: Maybe<String>;
  titre_not_ends_with?: Maybe<String>;
  AND?: Maybe<MactionWhereInput[] | MactionWhereInput>;
  OR?: Maybe<MactionWhereInput[] | MactionWhereInput>;
  NOT?: Maybe<MactionWhereInput[] | MactionWhereInput>;
}

export type MovementWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface MovementWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  created?: Maybe<DateTimeInput>;
  created_not?: Maybe<DateTimeInput>;
  created_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_lt?: Maybe<DateTimeInput>;
  created_lte?: Maybe<DateTimeInput>;
  created_gt?: Maybe<DateTimeInput>;
  created_gte?: Maybe<DateTimeInput>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  deleted?: Maybe<Boolean>;
  deleted_not?: Maybe<Boolean>;
  designation?: Maybe<String>;
  designation_not?: Maybe<String>;
  designation_in?: Maybe<String[] | String>;
  designation_not_in?: Maybe<String[] | String>;
  designation_lt?: Maybe<String>;
  designation_lte?: Maybe<String>;
  designation_gt?: Maybe<String>;
  designation_gte?: Maybe<String>;
  designation_contains?: Maybe<String>;
  designation_not_contains?: Maybe<String>;
  designation_starts_with?: Maybe<String>;
  designation_not_starts_with?: Maybe<String>;
  designation_ends_with?: Maybe<String>;
  designation_not_ends_with?: Maybe<String>;
  documentId?: Maybe<Int>;
  documentId_not?: Maybe<Int>;
  documentId_in?: Maybe<Int[] | Int>;
  documentId_not_in?: Maybe<Int[] | Int>;
  documentId_lt?: Maybe<Int>;
  documentId_lte?: Maybe<Int>;
  documentId_gt?: Maybe<Int>;
  documentId_gte?: Maybe<Int>;
  htTotal?: Maybe<Float>;
  htTotal_not?: Maybe<Float>;
  htTotal_in?: Maybe<Float[] | Float>;
  htTotal_not_in?: Maybe<Float[] | Float>;
  htTotal_lt?: Maybe<Float>;
  htTotal_lte?: Maybe<Float>;
  htTotal_gt?: Maybe<Float>;
  htTotal_gte?: Maybe<Float>;
  insertedId?: Maybe<Int>;
  insertedId_not?: Maybe<Int>;
  insertedId_in?: Maybe<Int[] | Int>;
  insertedId_not_in?: Maybe<Int[] | Int>;
  insertedId_lt?: Maybe<Int>;
  insertedId_lte?: Maybe<Int>;
  insertedId_gt?: Maybe<Int>;
  insertedId_gte?: Maybe<Int>;
  price?: Maybe<Float>;
  price_not?: Maybe<Float>;
  price_in?: Maybe<Float[] | Float>;
  price_not_in?: Maybe<Float[] | Float>;
  price_lt?: Maybe<Float>;
  price_lte?: Maybe<Float>;
  price_gt?: Maybe<Float>;
  price_gte?: Maybe<Float>;
  quantite?: Maybe<String>;
  quantite_not?: Maybe<String>;
  quantite_in?: Maybe<String[] | String>;
  quantite_not_in?: Maybe<String[] | String>;
  quantite_lt?: Maybe<String>;
  quantite_lte?: Maybe<String>;
  quantite_gt?: Maybe<String>;
  quantite_gte?: Maybe<String>;
  quantite_contains?: Maybe<String>;
  quantite_not_contains?: Maybe<String>;
  quantite_starts_with?: Maybe<String>;
  quantite_not_starts_with?: Maybe<String>;
  quantite_ends_with?: Maybe<String>;
  quantite_not_ends_with?: Maybe<String>;
  structureId?: Maybe<Int>;
  structureId_not?: Maybe<Int>;
  structureId_in?: Maybe<Int[] | Int>;
  structureId_not_in?: Maybe<Int[] | Int>;
  structureId_lt?: Maybe<Int>;
  structureId_lte?: Maybe<Int>;
  structureId_gt?: Maybe<Int>;
  structureId_gte?: Maybe<Int>;
  ttcTotal?: Maybe<Float>;
  ttcTotal_not?: Maybe<Float>;
  ttcTotal_in?: Maybe<Float[] | Float>;
  ttcTotal_not_in?: Maybe<Float[] | Float>;
  ttcTotal_lt?: Maybe<Float>;
  ttcTotal_lte?: Maybe<Float>;
  ttcTotal_gt?: Maybe<Float>;
  ttcTotal_gte?: Maybe<Float>;
  tvaId?: Maybe<Int>;
  tvaId_not?: Maybe<Int>;
  tvaId_in?: Maybe<Int[] | Int>;
  tvaId_not_in?: Maybe<Int[] | Int>;
  tvaId_lt?: Maybe<Int>;
  tvaId_lte?: Maybe<Int>;
  tvaId_gt?: Maybe<Int>;
  tvaId_gte?: Maybe<Int>;
  type?: Maybe<Boolean>;
  type_not?: Maybe<Boolean>;
  AND?: Maybe<MovementWhereInput[] | MovementWhereInput>;
  OR?: Maybe<MovementWhereInput[] | MovementWhereInput>;
  NOT?: Maybe<MovementWhereInput[] | MovementWhereInput>;
}

export type PersonWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export type StructureWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface UserWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  nom?: Maybe<String>;
  nom_not?: Maybe<String>;
  nom_in?: Maybe<String[] | String>;
  nom_not_in?: Maybe<String[] | String>;
  nom_lt?: Maybe<String>;
  nom_lte?: Maybe<String>;
  nom_gt?: Maybe<String>;
  nom_gte?: Maybe<String>;
  nom_contains?: Maybe<String>;
  nom_not_contains?: Maybe<String>;
  nom_starts_with?: Maybe<String>;
  nom_not_starts_with?: Maybe<String>;
  nom_ends_with?: Maybe<String>;
  nom_not_ends_with?: Maybe<String>;
  prenom?: Maybe<String>;
  prenom_not?: Maybe<String>;
  prenom_in?: Maybe<String[] | String>;
  prenom_not_in?: Maybe<String[] | String>;
  prenom_lt?: Maybe<String>;
  prenom_lte?: Maybe<String>;
  prenom_gt?: Maybe<String>;
  prenom_gte?: Maybe<String>;
  prenom_contains?: Maybe<String>;
  prenom_not_contains?: Maybe<String>;
  prenom_starts_with?: Maybe<String>;
  prenom_not_starts_with?: Maybe<String>;
  prenom_ends_with?: Maybe<String>;
  prenom_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  telephone?: Maybe<String>;
  telephone_not?: Maybe<String>;
  telephone_in?: Maybe<String[] | String>;
  telephone_not_in?: Maybe<String[] | String>;
  telephone_lt?: Maybe<String>;
  telephone_lte?: Maybe<String>;
  telephone_gt?: Maybe<String>;
  telephone_gte?: Maybe<String>;
  telephone_contains?: Maybe<String>;
  telephone_not_contains?: Maybe<String>;
  telephone_starts_with?: Maybe<String>;
  telephone_not_starts_with?: Maybe<String>;
  telephone_ends_with?: Maybe<String>;
  telephone_not_ends_with?: Maybe<String>;
  telephone2?: Maybe<String>;
  telephone2_not?: Maybe<String>;
  telephone2_in?: Maybe<String[] | String>;
  telephone2_not_in?: Maybe<String[] | String>;
  telephone2_lt?: Maybe<String>;
  telephone2_lte?: Maybe<String>;
  telephone2_gt?: Maybe<String>;
  telephone2_gte?: Maybe<String>;
  telephone2_contains?: Maybe<String>;
  telephone2_not_contains?: Maybe<String>;
  telephone2_starts_with?: Maybe<String>;
  telephone2_not_starts_with?: Maybe<String>;
  telephone2_ends_with?: Maybe<String>;
  telephone2_not_ends_with?: Maybe<String>;
  ville?: Maybe<String>;
  ville_not?: Maybe<String>;
  ville_in?: Maybe<String[] | String>;
  ville_not_in?: Maybe<String[] | String>;
  ville_lt?: Maybe<String>;
  ville_lte?: Maybe<String>;
  ville_gt?: Maybe<String>;
  ville_gte?: Maybe<String>;
  ville_contains?: Maybe<String>;
  ville_not_contains?: Maybe<String>;
  ville_starts_with?: Maybe<String>;
  ville_not_starts_with?: Maybe<String>;
  ville_ends_with?: Maybe<String>;
  ville_not_ends_with?: Maybe<String>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface ClientCreateInput {
  id?: Maybe<Int>;
  type?: Maybe<Boolean>;
  person?: Maybe<PersonCreateOneInput>;
  structure?: Maybe<StructureCreateOneInput>;
}

export interface PersonCreateOneInput {
  create?: Maybe<PersonCreateInput>;
  connect?: Maybe<PersonWhereUniqueInput>;
}

export interface PersonCreateInput {
  id?: Maybe<Int>;
  firstname?: Maybe<String>;
  lastname?: Maybe<String>;
}

export interface StructureCreateOneInput {
  create?: Maybe<StructureCreateInput>;
  connect?: Maybe<StructureWhereUniqueInput>;
}

export interface StructureCreateInput {
  id?: Maybe<Int>;
  raison_sociale?: Maybe<String>;
}

export interface ClientUpdateInput {
  type?: Maybe<Boolean>;
  person?: Maybe<PersonUpdateOneInput>;
  structure?: Maybe<StructureUpdateOneInput>;
}

export interface PersonUpdateOneInput {
  create?: Maybe<PersonCreateInput>;
  update?: Maybe<PersonUpdateDataInput>;
  upsert?: Maybe<PersonUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<PersonWhereUniqueInput>;
}

export interface PersonUpdateDataInput {
  firstname?: Maybe<String>;
  lastname?: Maybe<String>;
}

export interface PersonUpsertNestedInput {
  update: PersonUpdateDataInput;
  create: PersonCreateInput;
}

export interface StructureUpdateOneInput {
  create?: Maybe<StructureCreateInput>;
  update?: Maybe<StructureUpdateDataInput>;
  upsert?: Maybe<StructureUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<StructureWhereUniqueInput>;
}

export interface StructureUpdateDataInput {
  raison_sociale?: Maybe<String>;
}

export interface StructureUpsertNestedInput {
  update: StructureUpdateDataInput;
  create: StructureCreateInput;
}

export interface ClientUpdateManyMutationInput {
  type?: Maybe<Boolean>;
}

export interface ContactCreateInput {
  id?: Maybe<Int>;
  activite?: Maybe<String>;
  adresse?: Maybe<String>;
  adresseComplement?: Maybe<String>;
  civilite?: Maybe<Boolean>;
  comment?: Maybe<String>;
  companyName?: Maybe<String>;
  countryId?: Maybe<Int>;
  cp?: Maybe<String>;
  created?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  insertedId?: Maybe<Int>;
  lienSite?: Maybe<String>;
  nom: String;
  prenom?: Maybe<String>;
  structureId?: Maybe<Int>;
  tel1?: Maybe<String>;
  tel2?: Maybe<String>;
  ville?: Maybe<String>;
}

export interface ContactUpdateInput {
  activite?: Maybe<String>;
  adresse?: Maybe<String>;
  adresseComplement?: Maybe<String>;
  civilite?: Maybe<Boolean>;
  comment?: Maybe<String>;
  companyName?: Maybe<String>;
  countryId?: Maybe<Int>;
  cp?: Maybe<String>;
  created?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  insertedId?: Maybe<Int>;
  lienSite?: Maybe<String>;
  nom?: Maybe<String>;
  prenom?: Maybe<String>;
  structureId?: Maybe<Int>;
  tel1?: Maybe<String>;
  tel2?: Maybe<String>;
  ville?: Maybe<String>;
}

export interface ContactUpdateManyMutationInput {
  activite?: Maybe<String>;
  adresse?: Maybe<String>;
  adresseComplement?: Maybe<String>;
  civilite?: Maybe<Boolean>;
  comment?: Maybe<String>;
  companyName?: Maybe<String>;
  countryId?: Maybe<Int>;
  cp?: Maybe<String>;
  created?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  insertedId?: Maybe<Int>;
  lienSite?: Maybe<String>;
  nom?: Maybe<String>;
  prenom?: Maybe<String>;
  structureId?: Maybe<Int>;
  tel1?: Maybe<String>;
  tel2?: Maybe<String>;
  ville?: Maybe<String>;
}

export interface CountryCreateInput {
  id?: Maybe<Int>;
  code: String;
  name: String;
  ordre?: Maybe<Int>;
}

export interface CountryUpdateInput {
  code?: Maybe<String>;
  name?: Maybe<String>;
  ordre?: Maybe<Int>;
}

export interface CountryUpdateManyMutationInput {
  code?: Maybe<String>;
  name?: Maybe<String>;
  ordre?: Maybe<Int>;
}

export interface DepartmentCreateInput {
  id?: Maybe<Int>;
  deleted: Boolean;
  location: String;
  managerId: Int;
  name: String;
  structureId: Int;
  updated: DateTimeInput;
}

export interface DepartmentUpdateInput {
  deleted?: Maybe<Boolean>;
  location?: Maybe<String>;
  managerId?: Maybe<Int>;
  name?: Maybe<String>;
  structureId?: Maybe<Int>;
  updated?: Maybe<DateTimeInput>;
}

export interface DepartmentUpdateManyMutationInput {
  deleted?: Maybe<Boolean>;
  location?: Maybe<String>;
  managerId?: Maybe<Int>;
  name?: Maybe<String>;
  structureId?: Maybe<Int>;
  updated?: Maybe<DateTimeInput>;
}

export interface DevisModeleCreateInput {
  id?: Maybe<Int>;
  adresseId?: Maybe<Int>;
  created: DateTimeInput;
  deleted?: Maybe<Boolean>;
  modele?: Maybe<String>;
  name: String;
  structureId: Int;
  texteBas: String;
  updated?: Maybe<DateTimeInput>;
}

export interface DevisModeleUpdateInput {
  adresseId?: Maybe<Int>;
  created?: Maybe<DateTimeInput>;
  deleted?: Maybe<Boolean>;
  modele?: Maybe<String>;
  name?: Maybe<String>;
  structureId?: Maybe<Int>;
  texteBas?: Maybe<String>;
  updated?: Maybe<DateTimeInput>;
}

export interface DevisModeleUpdateManyMutationInput {
  adresseId?: Maybe<Int>;
  created?: Maybe<DateTimeInput>;
  deleted?: Maybe<Boolean>;
  modele?: Maybe<String>;
  name?: Maybe<String>;
  structureId?: Maybe<Int>;
  texteBas?: Maybe<String>;
  updated?: Maybe<DateTimeInput>;
}

export interface DocumentCreateInput {
  id?: Maybe<Int>;
  commentaire?: Maybe<String>;
  created: DateTimeInput;
  dateEmission?: Maybe<DateTimeInput>;
  deleted?: Maybe<Boolean>;
  documentTypeId?: Maybe<Int>;
  entityId?: Maybe<Int>;
  file: String;
  insertedId?: Maybe<Int>;
  name: String;
  public?: Maybe<Boolean>;
  structureId: Int;
  updated?: Maybe<DateTimeInput>;
  verEdition?: Maybe<Boolean>;
}

export interface DocumentUpdateInput {
  commentaire?: Maybe<String>;
  created?: Maybe<DateTimeInput>;
  dateEmission?: Maybe<DateTimeInput>;
  deleted?: Maybe<Boolean>;
  documentTypeId?: Maybe<Int>;
  entityId?: Maybe<Int>;
  file?: Maybe<String>;
  insertedId?: Maybe<Int>;
  name?: Maybe<String>;
  public?: Maybe<Boolean>;
  structureId?: Maybe<Int>;
  updated?: Maybe<DateTimeInput>;
  verEdition?: Maybe<Boolean>;
}

export interface DocumentUpdateManyMutationInput {
  commentaire?: Maybe<String>;
  created?: Maybe<DateTimeInput>;
  dateEmission?: Maybe<DateTimeInput>;
  deleted?: Maybe<Boolean>;
  documentTypeId?: Maybe<Int>;
  entityId?: Maybe<Int>;
  file?: Maybe<String>;
  insertedId?: Maybe<Int>;
  name?: Maybe<String>;
  public?: Maybe<Boolean>;
  structureId?: Maybe<Int>;
  updated?: Maybe<DateTimeInput>;
  verEdition?: Maybe<Boolean>;
}

export interface DocumentTypeCreateInput {
  id?: Maybe<Int>;
  title: String;
}

export interface DocumentTypeUpdateInput {
  title?: Maybe<String>;
}

export interface DocumentTypeUpdateManyMutationInput {
  title?: Maybe<String>;
}

export interface EmpInfoCreateInput {
  id?: Maybe<Int>;
  compteBancaire?: Maybe<String>;
  deleted?: Maybe<Boolean>;
  nbreEnfants?: Maybe<Int>;
  numCimr?: Maybe<String>;
  numCnss?: Maybe<String>;
  numMutuelle?: Maybe<String>;
  numPasseport?: Maybe<String>;
  situationFamiliale?: Maybe<Int>;
}

export interface EmpInfoUpdateInput {
  compteBancaire?: Maybe<String>;
  deleted?: Maybe<Boolean>;
  nbreEnfants?: Maybe<Int>;
  numCimr?: Maybe<String>;
  numCnss?: Maybe<String>;
  numMutuelle?: Maybe<String>;
  numPasseport?: Maybe<String>;
  situationFamiliale?: Maybe<Int>;
}

export interface EmpInfoUpdateManyMutationInput {
  compteBancaire?: Maybe<String>;
  deleted?: Maybe<Boolean>;
  nbreEnfants?: Maybe<Int>;
  numCimr?: Maybe<String>;
  numCnss?: Maybe<String>;
  numMutuelle?: Maybe<String>;
  numPasseport?: Maybe<String>;
  situationFamiliale?: Maybe<Int>;
}

export interface EmployeCreateInput {
  id?: Maybe<Int>;
  email?: Maybe<String>;
  adresseId?: Maybe<Int>;
  code?: Maybe<String>;
  deleted?: Maybe<Boolean>;
  departmentId?: Maybe<Int>;
  empInfoId?: Maybe<Int>;
  firstname: String;
  gender?: Maybe<Int>;
  hireDate?: Maybe<DateTimeInput>;
  jobId?: Maybe<Int>;
  lastname: String;
  managerId?: Maybe<Int>;
  phone1?: Maybe<String>;
  phone2?: Maybe<String>;
  salary?: Maybe<Float>;
  structureId?: Maybe<Int>;
  type?: Maybe<Boolean>;
  updated?: Maybe<DateTimeInput>;
}

export interface EmployeUpdateInput {
  email?: Maybe<String>;
  adresseId?: Maybe<Int>;
  code?: Maybe<String>;
  deleted?: Maybe<Boolean>;
  departmentId?: Maybe<Int>;
  empInfoId?: Maybe<Int>;
  firstname?: Maybe<String>;
  gender?: Maybe<Int>;
  hireDate?: Maybe<DateTimeInput>;
  jobId?: Maybe<Int>;
  lastname?: Maybe<String>;
  managerId?: Maybe<Int>;
  phone1?: Maybe<String>;
  phone2?: Maybe<String>;
  salary?: Maybe<Float>;
  structureId?: Maybe<Int>;
  type?: Maybe<Boolean>;
  updated?: Maybe<DateTimeInput>;
}

export interface EmployeUpdateManyMutationInput {
  email?: Maybe<String>;
  adresseId?: Maybe<Int>;
  code?: Maybe<String>;
  deleted?: Maybe<Boolean>;
  departmentId?: Maybe<Int>;
  empInfoId?: Maybe<Int>;
  firstname?: Maybe<String>;
  gender?: Maybe<Int>;
  hireDate?: Maybe<DateTimeInput>;
  jobId?: Maybe<Int>;
  lastname?: Maybe<String>;
  managerId?: Maybe<Int>;
  phone1?: Maybe<String>;
  phone2?: Maybe<String>;
  salary?: Maybe<Float>;
  structureId?: Maybe<Int>;
  type?: Maybe<Boolean>;
  updated?: Maybe<DateTimeInput>;
}

export interface EntityCreateInput {
  id?: Maybe<Int>;
  addressId: Int;
  deleted?: Maybe<Boolean>;
  name: String;
  seat: String;
  structureId: Int;
}

export interface EntityUpdateInput {
  addressId?: Maybe<Int>;
  deleted?: Maybe<Boolean>;
  name?: Maybe<String>;
  seat?: Maybe<String>;
  structureId?: Maybe<Int>;
}

export interface EntityUpdateManyMutationInput {
  addressId?: Maybe<Int>;
  deleted?: Maybe<Boolean>;
  name?: Maybe<String>;
  seat?: Maybe<String>;
  structureId?: Maybe<Int>;
}

export interface FileCreateInput {
  id?: Maybe<Int>;
  messageId: Int;
  nom: String;
}

export interface FileUpdateInput {
  messageId?: Maybe<Int>;
  nom?: Maybe<String>;
}

export interface FileUpdateManyMutationInput {
  messageId?: Maybe<Int>;
  nom?: Maybe<String>;
}

export interface JobCreateInput {
  id?: Maybe<Int>;
  deleted?: Maybe<Boolean>;
  description: String;
  keyword: String;
  maxSalary: Float;
  minSalary: Float;
  title: String;
}

export interface JobUpdateInput {
  deleted?: Maybe<Boolean>;
  description?: Maybe<String>;
  keyword?: Maybe<String>;
  maxSalary?: Maybe<Float>;
  minSalary?: Maybe<Float>;
  title?: Maybe<String>;
}

export interface JobUpdateManyMutationInput {
  deleted?: Maybe<Boolean>;
  description?: Maybe<String>;
  keyword?: Maybe<String>;
  maxSalary?: Maybe<Float>;
  minSalary?: Maybe<Float>;
  title?: Maybe<String>;
}

export interface LegalTypeCreateInput {
  id?: Maybe<Int>;
  code?: Maybe<String>;
  name: String;
}

export interface LegalTypeUpdateInput {
  code?: Maybe<String>;
  name?: Maybe<String>;
}

export interface LegalTypeUpdateManyMutationInput {
  code?: Maybe<String>;
  name?: Maybe<String>;
}

export interface MactionCreateInput {
  id?: Maybe<Int>;
  deleted?: Maybe<Boolean>;
  description?: Maybe<String>;
  effectuePar: String;
  memberId: Int;
  statut?: Maybe<Int>;
  titre: String;
}

export interface MactionUpdateInput {
  deleted?: Maybe<Boolean>;
  description?: Maybe<String>;
  effectuePar?: Maybe<String>;
  memberId?: Maybe<Int>;
  statut?: Maybe<Int>;
  titre?: Maybe<String>;
}

export interface MactionUpdateManyMutationInput {
  deleted?: Maybe<Boolean>;
  description?: Maybe<String>;
  effectuePar?: Maybe<String>;
  memberId?: Maybe<Int>;
  statut?: Maybe<Int>;
  titre?: Maybe<String>;
}

export interface MovementCreateInput {
  id?: Maybe<Int>;
  date?: Maybe<DateTimeInput>;
  deleted?: Maybe<Boolean>;
  designation: String;
  documentId?: Maybe<Int>;
  htTotal?: Maybe<Float>;
  insertedId?: Maybe<Int>;
  price?: Maybe<Float>;
  quantite?: Maybe<String>;
  structureId: Int;
  ttcTotal: Float;
  tvaId?: Maybe<Int>;
  type?: Maybe<Boolean>;
}

export interface MovementUpdateInput {
  date?: Maybe<DateTimeInput>;
  deleted?: Maybe<Boolean>;
  designation?: Maybe<String>;
  documentId?: Maybe<Int>;
  htTotal?: Maybe<Float>;
  insertedId?: Maybe<Int>;
  price?: Maybe<Float>;
  quantite?: Maybe<String>;
  structureId?: Maybe<Int>;
  ttcTotal?: Maybe<Float>;
  tvaId?: Maybe<Int>;
  type?: Maybe<Boolean>;
}

export interface MovementUpdateManyMutationInput {
  date?: Maybe<DateTimeInput>;
  deleted?: Maybe<Boolean>;
  designation?: Maybe<String>;
  documentId?: Maybe<Int>;
  htTotal?: Maybe<Float>;
  insertedId?: Maybe<Int>;
  price?: Maybe<Float>;
  quantite?: Maybe<String>;
  structureId?: Maybe<Int>;
  ttcTotal?: Maybe<Float>;
  tvaId?: Maybe<Int>;
  type?: Maybe<Boolean>;
}

export interface PersonUpdateInput {
  firstname?: Maybe<String>;
  lastname?: Maybe<String>;
}

export interface PersonUpdateManyMutationInput {
  firstname?: Maybe<String>;
  lastname?: Maybe<String>;
}

export interface StructureUpdateInput {
  raison_sociale?: Maybe<String>;
}

export interface StructureUpdateManyMutationInput {
  raison_sociale?: Maybe<String>;
}

export interface UserCreateInput {
  id?: Maybe<Int>;
  email: String;
  nom?: Maybe<String>;
  prenom?: Maybe<String>;
  password: String;
  telephone?: Maybe<String>;
  telephone2?: Maybe<String>;
  ville?: Maybe<String>;
}

export interface UserUpdateInput {
  email?: Maybe<String>;
  nom?: Maybe<String>;
  prenom?: Maybe<String>;
  password?: Maybe<String>;
  telephone?: Maybe<String>;
  telephone2?: Maybe<String>;
  ville?: Maybe<String>;
}

export interface UserUpdateManyMutationInput {
  email?: Maybe<String>;
  nom?: Maybe<String>;
  prenom?: Maybe<String>;
  password?: Maybe<String>;
  telephone?: Maybe<String>;
  telephone2?: Maybe<String>;
  ville?: Maybe<String>;
}

export interface ClientSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ClientWhereInput>;
  AND?: Maybe<ClientSubscriptionWhereInput[] | ClientSubscriptionWhereInput>;
  OR?: Maybe<ClientSubscriptionWhereInput[] | ClientSubscriptionWhereInput>;
  NOT?: Maybe<ClientSubscriptionWhereInput[] | ClientSubscriptionWhereInput>;
}

export interface ContactSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ContactWhereInput>;
  AND?: Maybe<ContactSubscriptionWhereInput[] | ContactSubscriptionWhereInput>;
  OR?: Maybe<ContactSubscriptionWhereInput[] | ContactSubscriptionWhereInput>;
  NOT?: Maybe<ContactSubscriptionWhereInput[] | ContactSubscriptionWhereInput>;
}

export interface CountrySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CountryWhereInput>;
  AND?: Maybe<CountrySubscriptionWhereInput[] | CountrySubscriptionWhereInput>;
  OR?: Maybe<CountrySubscriptionWhereInput[] | CountrySubscriptionWhereInput>;
  NOT?: Maybe<CountrySubscriptionWhereInput[] | CountrySubscriptionWhereInput>;
}

export interface DepartmentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DepartmentWhereInput>;
  AND?: Maybe<
    DepartmentSubscriptionWhereInput[] | DepartmentSubscriptionWhereInput
  >;
  OR?: Maybe<
    DepartmentSubscriptionWhereInput[] | DepartmentSubscriptionWhereInput
  >;
  NOT?: Maybe<
    DepartmentSubscriptionWhereInput[] | DepartmentSubscriptionWhereInput
  >;
}

export interface DevisModeleSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DevisModeleWhereInput>;
  AND?: Maybe<
    DevisModeleSubscriptionWhereInput[] | DevisModeleSubscriptionWhereInput
  >;
  OR?: Maybe<
    DevisModeleSubscriptionWhereInput[] | DevisModeleSubscriptionWhereInput
  >;
  NOT?: Maybe<
    DevisModeleSubscriptionWhereInput[] | DevisModeleSubscriptionWhereInput
  >;
}

export interface DocumentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DocumentWhereInput>;
  AND?: Maybe<
    DocumentSubscriptionWhereInput[] | DocumentSubscriptionWhereInput
  >;
  OR?: Maybe<DocumentSubscriptionWhereInput[] | DocumentSubscriptionWhereInput>;
  NOT?: Maybe<
    DocumentSubscriptionWhereInput[] | DocumentSubscriptionWhereInput
  >;
}

export interface DocumentTypeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DocumentTypeWhereInput>;
  AND?: Maybe<
    DocumentTypeSubscriptionWhereInput[] | DocumentTypeSubscriptionWhereInput
  >;
  OR?: Maybe<
    DocumentTypeSubscriptionWhereInput[] | DocumentTypeSubscriptionWhereInput
  >;
  NOT?: Maybe<
    DocumentTypeSubscriptionWhereInput[] | DocumentTypeSubscriptionWhereInput
  >;
}

export interface EmpInfoSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EmpInfoWhereInput>;
  AND?: Maybe<EmpInfoSubscriptionWhereInput[] | EmpInfoSubscriptionWhereInput>;
  OR?: Maybe<EmpInfoSubscriptionWhereInput[] | EmpInfoSubscriptionWhereInput>;
  NOT?: Maybe<EmpInfoSubscriptionWhereInput[] | EmpInfoSubscriptionWhereInput>;
}

export interface EmployeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EmployeWhereInput>;
  AND?: Maybe<EmployeSubscriptionWhereInput[] | EmployeSubscriptionWhereInput>;
  OR?: Maybe<EmployeSubscriptionWhereInput[] | EmployeSubscriptionWhereInput>;
  NOT?: Maybe<EmployeSubscriptionWhereInput[] | EmployeSubscriptionWhereInput>;
}

export interface EntitySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EntityWhereInput>;
  AND?: Maybe<EntitySubscriptionWhereInput[] | EntitySubscriptionWhereInput>;
  OR?: Maybe<EntitySubscriptionWhereInput[] | EntitySubscriptionWhereInput>;
  NOT?: Maybe<EntitySubscriptionWhereInput[] | EntitySubscriptionWhereInput>;
}

export interface FileSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FileWhereInput>;
  AND?: Maybe<FileSubscriptionWhereInput[] | FileSubscriptionWhereInput>;
  OR?: Maybe<FileSubscriptionWhereInput[] | FileSubscriptionWhereInput>;
  NOT?: Maybe<FileSubscriptionWhereInput[] | FileSubscriptionWhereInput>;
}

export interface JobSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<JobWhereInput>;
  AND?: Maybe<JobSubscriptionWhereInput[] | JobSubscriptionWhereInput>;
  OR?: Maybe<JobSubscriptionWhereInput[] | JobSubscriptionWhereInput>;
  NOT?: Maybe<JobSubscriptionWhereInput[] | JobSubscriptionWhereInput>;
}

export interface LegalTypeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LegalTypeWhereInput>;
  AND?: Maybe<
    LegalTypeSubscriptionWhereInput[] | LegalTypeSubscriptionWhereInput
  >;
  OR?: Maybe<
    LegalTypeSubscriptionWhereInput[] | LegalTypeSubscriptionWhereInput
  >;
  NOT?: Maybe<
    LegalTypeSubscriptionWhereInput[] | LegalTypeSubscriptionWhereInput
  >;
}

export interface MactionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MactionWhereInput>;
  AND?: Maybe<MactionSubscriptionWhereInput[] | MactionSubscriptionWhereInput>;
  OR?: Maybe<MactionSubscriptionWhereInput[] | MactionSubscriptionWhereInput>;
  NOT?: Maybe<MactionSubscriptionWhereInput[] | MactionSubscriptionWhereInput>;
}

export interface MovementSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MovementWhereInput>;
  AND?: Maybe<
    MovementSubscriptionWhereInput[] | MovementSubscriptionWhereInput
  >;
  OR?: Maybe<MovementSubscriptionWhereInput[] | MovementSubscriptionWhereInput>;
  NOT?: Maybe<
    MovementSubscriptionWhereInput[] | MovementSubscriptionWhereInput
  >;
}

export interface PersonSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PersonWhereInput>;
  AND?: Maybe<PersonSubscriptionWhereInput[] | PersonSubscriptionWhereInput>;
  OR?: Maybe<PersonSubscriptionWhereInput[] | PersonSubscriptionWhereInput>;
  NOT?: Maybe<PersonSubscriptionWhereInput[] | PersonSubscriptionWhereInput>;
}

export interface StructureSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<StructureWhereInput>;
  AND?: Maybe<
    StructureSubscriptionWhereInput[] | StructureSubscriptionWhereInput
  >;
  OR?: Maybe<
    StructureSubscriptionWhereInput[] | StructureSubscriptionWhereInput
  >;
  NOT?: Maybe<
    StructureSubscriptionWhereInput[] | StructureSubscriptionWhereInput
  >;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Client {
  id: Int;
  type?: Boolean;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface ClientPromise extends Promise<Client>, Fragmentable {
  id: () => Promise<Int>;
  type: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  person: <T = PersonPromise>() => T;
  structure: <T = StructurePromise>() => T;
}

export interface ClientSubscription
  extends Promise<AsyncIterator<Client>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  person: <T = PersonSubscription>() => T;
  structure: <T = StructureSubscription>() => T;
}

export interface ClientNullablePromise
  extends Promise<Client | null>,
    Fragmentable {
  id: () => Promise<Int>;
  type: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  person: <T = PersonPromise>() => T;
  structure: <T = StructurePromise>() => T;
}

export interface Person {
  id: Int;
  firstname?: String;
  lastname?: String;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface PersonPromise extends Promise<Person>, Fragmentable {
  id: () => Promise<Int>;
  firstname: () => Promise<String>;
  lastname: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PersonSubscription
  extends Promise<AsyncIterator<Person>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  firstname: () => Promise<AsyncIterator<String>>;
  lastname: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PersonNullablePromise
  extends Promise<Person | null>,
    Fragmentable {
  id: () => Promise<Int>;
  firstname: () => Promise<String>;
  lastname: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Structure {
  id: Int;
  raison_sociale?: String;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface StructurePromise extends Promise<Structure>, Fragmentable {
  id: () => Promise<Int>;
  raison_sociale: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface StructureSubscription
  extends Promise<AsyncIterator<Structure>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  raison_sociale: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface StructureNullablePromise
  extends Promise<Structure | null>,
    Fragmentable {
  id: () => Promise<Int>;
  raison_sociale: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ClientConnection {
  pageInfo: PageInfo;
  edges: ClientEdge[];
}

export interface ClientConnectionPromise
  extends Promise<ClientConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ClientEdge>>() => T;
  aggregate: <T = AggregateClientPromise>() => T;
}

export interface ClientConnectionSubscription
  extends Promise<AsyncIterator<ClientConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ClientEdgeSubscription>>>() => T;
  aggregate: <T = AggregateClientSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ClientEdge {
  node: Client;
  cursor: String;
}

export interface ClientEdgePromise extends Promise<ClientEdge>, Fragmentable {
  node: <T = ClientPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ClientEdgeSubscription
  extends Promise<AsyncIterator<ClientEdge>>,
    Fragmentable {
  node: <T = ClientSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateClient {
  count: Int;
}

export interface AggregateClientPromise
  extends Promise<AggregateClient>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateClientSubscription
  extends Promise<AsyncIterator<AggregateClient>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Contact {
  id: Int;
  activite?: String;
  adresse?: String;
  adresseComplement?: String;
  civilite: Boolean;
  comment?: String;
  companyName?: String;
  countryId: Int;
  cp?: String;
  created?: DateTimeOutput;
  email?: String;
  insertedId?: Int;
  lienSite?: String;
  nom: String;
  prenom?: String;
  structureId?: Int;
  tel1?: String;
  tel2?: String;
  ville?: String;
}

export interface ContactPromise extends Promise<Contact>, Fragmentable {
  id: () => Promise<Int>;
  activite: () => Promise<String>;
  adresse: () => Promise<String>;
  adresseComplement: () => Promise<String>;
  civilite: () => Promise<Boolean>;
  comment: () => Promise<String>;
  companyName: () => Promise<String>;
  countryId: () => Promise<Int>;
  cp: () => Promise<String>;
  created: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  insertedId: () => Promise<Int>;
  lienSite: () => Promise<String>;
  nom: () => Promise<String>;
  prenom: () => Promise<String>;
  structureId: () => Promise<Int>;
  tel1: () => Promise<String>;
  tel2: () => Promise<String>;
  ville: () => Promise<String>;
}

export interface ContactSubscription
  extends Promise<AsyncIterator<Contact>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  activite: () => Promise<AsyncIterator<String>>;
  adresse: () => Promise<AsyncIterator<String>>;
  adresseComplement: () => Promise<AsyncIterator<String>>;
  civilite: () => Promise<AsyncIterator<Boolean>>;
  comment: () => Promise<AsyncIterator<String>>;
  companyName: () => Promise<AsyncIterator<String>>;
  countryId: () => Promise<AsyncIterator<Int>>;
  cp: () => Promise<AsyncIterator<String>>;
  created: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  insertedId: () => Promise<AsyncIterator<Int>>;
  lienSite: () => Promise<AsyncIterator<String>>;
  nom: () => Promise<AsyncIterator<String>>;
  prenom: () => Promise<AsyncIterator<String>>;
  structureId: () => Promise<AsyncIterator<Int>>;
  tel1: () => Promise<AsyncIterator<String>>;
  tel2: () => Promise<AsyncIterator<String>>;
  ville: () => Promise<AsyncIterator<String>>;
}

export interface ContactNullablePromise
  extends Promise<Contact | null>,
    Fragmentable {
  id: () => Promise<Int>;
  activite: () => Promise<String>;
  adresse: () => Promise<String>;
  adresseComplement: () => Promise<String>;
  civilite: () => Promise<Boolean>;
  comment: () => Promise<String>;
  companyName: () => Promise<String>;
  countryId: () => Promise<Int>;
  cp: () => Promise<String>;
  created: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  insertedId: () => Promise<Int>;
  lienSite: () => Promise<String>;
  nom: () => Promise<String>;
  prenom: () => Promise<String>;
  structureId: () => Promise<Int>;
  tel1: () => Promise<String>;
  tel2: () => Promise<String>;
  ville: () => Promise<String>;
}

export interface ContactConnection {
  pageInfo: PageInfo;
  edges: ContactEdge[];
}

export interface ContactConnectionPromise
  extends Promise<ContactConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ContactEdge>>() => T;
  aggregate: <T = AggregateContactPromise>() => T;
}

export interface ContactConnectionSubscription
  extends Promise<AsyncIterator<ContactConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ContactEdgeSubscription>>>() => T;
  aggregate: <T = AggregateContactSubscription>() => T;
}

export interface ContactEdge {
  node: Contact;
  cursor: String;
}

export interface ContactEdgePromise extends Promise<ContactEdge>, Fragmentable {
  node: <T = ContactPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ContactEdgeSubscription
  extends Promise<AsyncIterator<ContactEdge>>,
    Fragmentable {
  node: <T = ContactSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateContact {
  count: Int;
}

export interface AggregateContactPromise
  extends Promise<AggregateContact>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateContactSubscription
  extends Promise<AsyncIterator<AggregateContact>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Country {
  id: Int;
  code: String;
  name: String;
  ordre: Int;
}

export interface CountryPromise extends Promise<Country>, Fragmentable {
  id: () => Promise<Int>;
  code: () => Promise<String>;
  name: () => Promise<String>;
  ordre: () => Promise<Int>;
}

export interface CountrySubscription
  extends Promise<AsyncIterator<Country>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  code: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  ordre: () => Promise<AsyncIterator<Int>>;
}

export interface CountryNullablePromise
  extends Promise<Country | null>,
    Fragmentable {
  id: () => Promise<Int>;
  code: () => Promise<String>;
  name: () => Promise<String>;
  ordre: () => Promise<Int>;
}

export interface CountryConnection {
  pageInfo: PageInfo;
  edges: CountryEdge[];
}

export interface CountryConnectionPromise
  extends Promise<CountryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CountryEdge>>() => T;
  aggregate: <T = AggregateCountryPromise>() => T;
}

export interface CountryConnectionSubscription
  extends Promise<AsyncIterator<CountryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CountryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCountrySubscription>() => T;
}

export interface CountryEdge {
  node: Country;
  cursor: String;
}

export interface CountryEdgePromise extends Promise<CountryEdge>, Fragmentable {
  node: <T = CountryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CountryEdgeSubscription
  extends Promise<AsyncIterator<CountryEdge>>,
    Fragmentable {
  node: <T = CountrySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCountry {
  count: Int;
}

export interface AggregateCountryPromise
  extends Promise<AggregateCountry>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCountrySubscription
  extends Promise<AsyncIterator<AggregateCountry>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Department {
  id: Int;
  created: DateTimeOutput;
  deleted: Boolean;
  location: String;
  managerId: Int;
  name: String;
  structureId: Int;
  updated: DateTimeOutput;
}

export interface DepartmentPromise extends Promise<Department>, Fragmentable {
  id: () => Promise<Int>;
  created: () => Promise<DateTimeOutput>;
  deleted: () => Promise<Boolean>;
  location: () => Promise<String>;
  managerId: () => Promise<Int>;
  name: () => Promise<String>;
  structureId: () => Promise<Int>;
  updated: () => Promise<DateTimeOutput>;
}

export interface DepartmentSubscription
  extends Promise<AsyncIterator<Department>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  created: () => Promise<AsyncIterator<DateTimeOutput>>;
  deleted: () => Promise<AsyncIterator<Boolean>>;
  location: () => Promise<AsyncIterator<String>>;
  managerId: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  structureId: () => Promise<AsyncIterator<Int>>;
  updated: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DepartmentNullablePromise
  extends Promise<Department | null>,
    Fragmentable {
  id: () => Promise<Int>;
  created: () => Promise<DateTimeOutput>;
  deleted: () => Promise<Boolean>;
  location: () => Promise<String>;
  managerId: () => Promise<Int>;
  name: () => Promise<String>;
  structureId: () => Promise<Int>;
  updated: () => Promise<DateTimeOutput>;
}

export interface DepartmentConnection {
  pageInfo: PageInfo;
  edges: DepartmentEdge[];
}

export interface DepartmentConnectionPromise
  extends Promise<DepartmentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DepartmentEdge>>() => T;
  aggregate: <T = AggregateDepartmentPromise>() => T;
}

export interface DepartmentConnectionSubscription
  extends Promise<AsyncIterator<DepartmentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DepartmentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDepartmentSubscription>() => T;
}

export interface DepartmentEdge {
  node: Department;
  cursor: String;
}

export interface DepartmentEdgePromise
  extends Promise<DepartmentEdge>,
    Fragmentable {
  node: <T = DepartmentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DepartmentEdgeSubscription
  extends Promise<AsyncIterator<DepartmentEdge>>,
    Fragmentable {
  node: <T = DepartmentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDepartment {
  count: Int;
}

export interface AggregateDepartmentPromise
  extends Promise<AggregateDepartment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDepartmentSubscription
  extends Promise<AsyncIterator<AggregateDepartment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DevisModele {
  id: Int;
  adresseId?: Int;
  created: DateTimeOutput;
  deleted: Boolean;
  modele?: String;
  name: String;
  structureId: Int;
  texteBas: String;
  updated?: DateTimeOutput;
}

export interface DevisModelePromise extends Promise<DevisModele>, Fragmentable {
  id: () => Promise<Int>;
  adresseId: () => Promise<Int>;
  created: () => Promise<DateTimeOutput>;
  deleted: () => Promise<Boolean>;
  modele: () => Promise<String>;
  name: () => Promise<String>;
  structureId: () => Promise<Int>;
  texteBas: () => Promise<String>;
  updated: () => Promise<DateTimeOutput>;
}

export interface DevisModeleSubscription
  extends Promise<AsyncIterator<DevisModele>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  adresseId: () => Promise<AsyncIterator<Int>>;
  created: () => Promise<AsyncIterator<DateTimeOutput>>;
  deleted: () => Promise<AsyncIterator<Boolean>>;
  modele: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  structureId: () => Promise<AsyncIterator<Int>>;
  texteBas: () => Promise<AsyncIterator<String>>;
  updated: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DevisModeleNullablePromise
  extends Promise<DevisModele | null>,
    Fragmentable {
  id: () => Promise<Int>;
  adresseId: () => Promise<Int>;
  created: () => Promise<DateTimeOutput>;
  deleted: () => Promise<Boolean>;
  modele: () => Promise<String>;
  name: () => Promise<String>;
  structureId: () => Promise<Int>;
  texteBas: () => Promise<String>;
  updated: () => Promise<DateTimeOutput>;
}

export interface DevisModeleConnection {
  pageInfo: PageInfo;
  edges: DevisModeleEdge[];
}

export interface DevisModeleConnectionPromise
  extends Promise<DevisModeleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DevisModeleEdge>>() => T;
  aggregate: <T = AggregateDevisModelePromise>() => T;
}

export interface DevisModeleConnectionSubscription
  extends Promise<AsyncIterator<DevisModeleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DevisModeleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDevisModeleSubscription>() => T;
}

export interface DevisModeleEdge {
  node: DevisModele;
  cursor: String;
}

export interface DevisModeleEdgePromise
  extends Promise<DevisModeleEdge>,
    Fragmentable {
  node: <T = DevisModelePromise>() => T;
  cursor: () => Promise<String>;
}

export interface DevisModeleEdgeSubscription
  extends Promise<AsyncIterator<DevisModeleEdge>>,
    Fragmentable {
  node: <T = DevisModeleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDevisModele {
  count: Int;
}

export interface AggregateDevisModelePromise
  extends Promise<AggregateDevisModele>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDevisModeleSubscription
  extends Promise<AsyncIterator<AggregateDevisModele>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Document {
  id: Int;
  commentaire?: String;
  created: DateTimeOutput;
  dateEmission?: DateTimeOutput;
  deleted: Boolean;
  documentTypeId: Int;
  entityId: Int;
  file: String;
  insertedId?: Int;
  name: String;
  public: Boolean;
  structureId: Int;
  updated?: DateTimeOutput;
  verEdition: Boolean;
}

export interface DocumentPromise extends Promise<Document>, Fragmentable {
  id: () => Promise<Int>;
  commentaire: () => Promise<String>;
  created: () => Promise<DateTimeOutput>;
  dateEmission: () => Promise<DateTimeOutput>;
  deleted: () => Promise<Boolean>;
  documentTypeId: () => Promise<Int>;
  entityId: () => Promise<Int>;
  file: () => Promise<String>;
  insertedId: () => Promise<Int>;
  name: () => Promise<String>;
  public: () => Promise<Boolean>;
  structureId: () => Promise<Int>;
  updated: () => Promise<DateTimeOutput>;
  verEdition: () => Promise<Boolean>;
}

export interface DocumentSubscription
  extends Promise<AsyncIterator<Document>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  commentaire: () => Promise<AsyncIterator<String>>;
  created: () => Promise<AsyncIterator<DateTimeOutput>>;
  dateEmission: () => Promise<AsyncIterator<DateTimeOutput>>;
  deleted: () => Promise<AsyncIterator<Boolean>>;
  documentTypeId: () => Promise<AsyncIterator<Int>>;
  entityId: () => Promise<AsyncIterator<Int>>;
  file: () => Promise<AsyncIterator<String>>;
  insertedId: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  public: () => Promise<AsyncIterator<Boolean>>;
  structureId: () => Promise<AsyncIterator<Int>>;
  updated: () => Promise<AsyncIterator<DateTimeOutput>>;
  verEdition: () => Promise<AsyncIterator<Boolean>>;
}

export interface DocumentNullablePromise
  extends Promise<Document | null>,
    Fragmentable {
  id: () => Promise<Int>;
  commentaire: () => Promise<String>;
  created: () => Promise<DateTimeOutput>;
  dateEmission: () => Promise<DateTimeOutput>;
  deleted: () => Promise<Boolean>;
  documentTypeId: () => Promise<Int>;
  entityId: () => Promise<Int>;
  file: () => Promise<String>;
  insertedId: () => Promise<Int>;
  name: () => Promise<String>;
  public: () => Promise<Boolean>;
  structureId: () => Promise<Int>;
  updated: () => Promise<DateTimeOutput>;
  verEdition: () => Promise<Boolean>;
}

export interface DocumentConnection {
  pageInfo: PageInfo;
  edges: DocumentEdge[];
}

export interface DocumentConnectionPromise
  extends Promise<DocumentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DocumentEdge>>() => T;
  aggregate: <T = AggregateDocumentPromise>() => T;
}

export interface DocumentConnectionSubscription
  extends Promise<AsyncIterator<DocumentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DocumentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDocumentSubscription>() => T;
}

export interface DocumentEdge {
  node: Document;
  cursor: String;
}

export interface DocumentEdgePromise
  extends Promise<DocumentEdge>,
    Fragmentable {
  node: <T = DocumentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DocumentEdgeSubscription
  extends Promise<AsyncIterator<DocumentEdge>>,
    Fragmentable {
  node: <T = DocumentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDocument {
  count: Int;
}

export interface AggregateDocumentPromise
  extends Promise<AggregateDocument>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDocumentSubscription
  extends Promise<AsyncIterator<AggregateDocument>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DocumentType {
  id: Int;
  title: String;
}

export interface DocumentTypePromise
  extends Promise<DocumentType>,
    Fragmentable {
  id: () => Promise<Int>;
  title: () => Promise<String>;
}

export interface DocumentTypeSubscription
  extends Promise<AsyncIterator<DocumentType>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  title: () => Promise<AsyncIterator<String>>;
}

export interface DocumentTypeNullablePromise
  extends Promise<DocumentType | null>,
    Fragmentable {
  id: () => Promise<Int>;
  title: () => Promise<String>;
}

export interface DocumentTypeConnection {
  pageInfo: PageInfo;
  edges: DocumentTypeEdge[];
}

export interface DocumentTypeConnectionPromise
  extends Promise<DocumentTypeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DocumentTypeEdge>>() => T;
  aggregate: <T = AggregateDocumentTypePromise>() => T;
}

export interface DocumentTypeConnectionSubscription
  extends Promise<AsyncIterator<DocumentTypeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DocumentTypeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDocumentTypeSubscription>() => T;
}

export interface DocumentTypeEdge {
  node: DocumentType;
  cursor: String;
}

export interface DocumentTypeEdgePromise
  extends Promise<DocumentTypeEdge>,
    Fragmentable {
  node: <T = DocumentTypePromise>() => T;
  cursor: () => Promise<String>;
}

export interface DocumentTypeEdgeSubscription
  extends Promise<AsyncIterator<DocumentTypeEdge>>,
    Fragmentable {
  node: <T = DocumentTypeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDocumentType {
  count: Int;
}

export interface AggregateDocumentTypePromise
  extends Promise<AggregateDocumentType>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDocumentTypeSubscription
  extends Promise<AsyncIterator<AggregateDocumentType>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EmpInfo {
  id: Int;
  compteBancaire?: String;
  created?: DateTimeOutput;
  deleted?: Boolean;
  nbreEnfants?: Int;
  numCimr?: String;
  numCnss?: String;
  numMutuelle?: String;
  numPasseport?: String;
  situationFamiliale?: Int;
  updated?: DateTimeOutput;
}

export interface EmpInfoPromise extends Promise<EmpInfo>, Fragmentable {
  id: () => Promise<Int>;
  compteBancaire: () => Promise<String>;
  created: () => Promise<DateTimeOutput>;
  deleted: () => Promise<Boolean>;
  nbreEnfants: () => Promise<Int>;
  numCimr: () => Promise<String>;
  numCnss: () => Promise<String>;
  numMutuelle: () => Promise<String>;
  numPasseport: () => Promise<String>;
  situationFamiliale: () => Promise<Int>;
  updated: () => Promise<DateTimeOutput>;
}

export interface EmpInfoSubscription
  extends Promise<AsyncIterator<EmpInfo>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  compteBancaire: () => Promise<AsyncIterator<String>>;
  created: () => Promise<AsyncIterator<DateTimeOutput>>;
  deleted: () => Promise<AsyncIterator<Boolean>>;
  nbreEnfants: () => Promise<AsyncIterator<Int>>;
  numCimr: () => Promise<AsyncIterator<String>>;
  numCnss: () => Promise<AsyncIterator<String>>;
  numMutuelle: () => Promise<AsyncIterator<String>>;
  numPasseport: () => Promise<AsyncIterator<String>>;
  situationFamiliale: () => Promise<AsyncIterator<Int>>;
  updated: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface EmpInfoNullablePromise
  extends Promise<EmpInfo | null>,
    Fragmentable {
  id: () => Promise<Int>;
  compteBancaire: () => Promise<String>;
  created: () => Promise<DateTimeOutput>;
  deleted: () => Promise<Boolean>;
  nbreEnfants: () => Promise<Int>;
  numCimr: () => Promise<String>;
  numCnss: () => Promise<String>;
  numMutuelle: () => Promise<String>;
  numPasseport: () => Promise<String>;
  situationFamiliale: () => Promise<Int>;
  updated: () => Promise<DateTimeOutput>;
}

export interface EmpInfoConnection {
  pageInfo: PageInfo;
  edges: EmpInfoEdge[];
}

export interface EmpInfoConnectionPromise
  extends Promise<EmpInfoConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EmpInfoEdge>>() => T;
  aggregate: <T = AggregateEmpInfoPromise>() => T;
}

export interface EmpInfoConnectionSubscription
  extends Promise<AsyncIterator<EmpInfoConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EmpInfoEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEmpInfoSubscription>() => T;
}

export interface EmpInfoEdge {
  node: EmpInfo;
  cursor: String;
}

export interface EmpInfoEdgePromise extends Promise<EmpInfoEdge>, Fragmentable {
  node: <T = EmpInfoPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EmpInfoEdgeSubscription
  extends Promise<AsyncIterator<EmpInfoEdge>>,
    Fragmentable {
  node: <T = EmpInfoSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEmpInfo {
  count: Int;
}

export interface AggregateEmpInfoPromise
  extends Promise<AggregateEmpInfo>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEmpInfoSubscription
  extends Promise<AsyncIterator<AggregateEmpInfo>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Employe {
  id: Int;
  email?: String;
  adresseId?: Int;
  code?: String;
  created: DateTimeOutput;
  deleted?: Boolean;
  departmentId?: Int;
  empInfoId?: Int;
  firstname: String;
  gender?: Int;
  hireDate?: DateTimeOutput;
  jobId?: Int;
  lastname: String;
  managerId?: Int;
  phone1?: String;
  phone2?: String;
  salary?: Float;
  structureId?: Int;
  type?: Boolean;
  updated?: DateTimeOutput;
}

export interface EmployePromise extends Promise<Employe>, Fragmentable {
  id: () => Promise<Int>;
  email: () => Promise<String>;
  adresseId: () => Promise<Int>;
  code: () => Promise<String>;
  created: () => Promise<DateTimeOutput>;
  deleted: () => Promise<Boolean>;
  departmentId: () => Promise<Int>;
  empInfoId: () => Promise<Int>;
  firstname: () => Promise<String>;
  gender: () => Promise<Int>;
  hireDate: () => Promise<DateTimeOutput>;
  jobId: () => Promise<Int>;
  lastname: () => Promise<String>;
  managerId: () => Promise<Int>;
  phone1: () => Promise<String>;
  phone2: () => Promise<String>;
  salary: () => Promise<Float>;
  structureId: () => Promise<Int>;
  type: () => Promise<Boolean>;
  updated: () => Promise<DateTimeOutput>;
}

export interface EmployeSubscription
  extends Promise<AsyncIterator<Employe>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  email: () => Promise<AsyncIterator<String>>;
  adresseId: () => Promise<AsyncIterator<Int>>;
  code: () => Promise<AsyncIterator<String>>;
  created: () => Promise<AsyncIterator<DateTimeOutput>>;
  deleted: () => Promise<AsyncIterator<Boolean>>;
  departmentId: () => Promise<AsyncIterator<Int>>;
  empInfoId: () => Promise<AsyncIterator<Int>>;
  firstname: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<Int>>;
  hireDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  jobId: () => Promise<AsyncIterator<Int>>;
  lastname: () => Promise<AsyncIterator<String>>;
  managerId: () => Promise<AsyncIterator<Int>>;
  phone1: () => Promise<AsyncIterator<String>>;
  phone2: () => Promise<AsyncIterator<String>>;
  salary: () => Promise<AsyncIterator<Float>>;
  structureId: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<Boolean>>;
  updated: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface EmployeNullablePromise
  extends Promise<Employe | null>,
    Fragmentable {
  id: () => Promise<Int>;
  email: () => Promise<String>;
  adresseId: () => Promise<Int>;
  code: () => Promise<String>;
  created: () => Promise<DateTimeOutput>;
  deleted: () => Promise<Boolean>;
  departmentId: () => Promise<Int>;
  empInfoId: () => Promise<Int>;
  firstname: () => Promise<String>;
  gender: () => Promise<Int>;
  hireDate: () => Promise<DateTimeOutput>;
  jobId: () => Promise<Int>;
  lastname: () => Promise<String>;
  managerId: () => Promise<Int>;
  phone1: () => Promise<String>;
  phone2: () => Promise<String>;
  salary: () => Promise<Float>;
  structureId: () => Promise<Int>;
  type: () => Promise<Boolean>;
  updated: () => Promise<DateTimeOutput>;
}

export interface EmployeConnection {
  pageInfo: PageInfo;
  edges: EmployeEdge[];
}

export interface EmployeConnectionPromise
  extends Promise<EmployeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EmployeEdge>>() => T;
  aggregate: <T = AggregateEmployePromise>() => T;
}

export interface EmployeConnectionSubscription
  extends Promise<AsyncIterator<EmployeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EmployeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEmployeSubscription>() => T;
}

export interface EmployeEdge {
  node: Employe;
  cursor: String;
}

export interface EmployeEdgePromise extends Promise<EmployeEdge>, Fragmentable {
  node: <T = EmployePromise>() => T;
  cursor: () => Promise<String>;
}

export interface EmployeEdgeSubscription
  extends Promise<AsyncIterator<EmployeEdge>>,
    Fragmentable {
  node: <T = EmployeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEmploye {
  count: Int;
}

export interface AggregateEmployePromise
  extends Promise<AggregateEmploye>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEmployeSubscription
  extends Promise<AsyncIterator<AggregateEmploye>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Entity {
  id: Int;
  addressId: Int;
  created: DateTimeOutput;
  deleted: Boolean;
  name: String;
  seat: String;
  structureId: Int;
  updated?: DateTimeOutput;
}

export interface EntityPromise extends Promise<Entity>, Fragmentable {
  id: () => Promise<Int>;
  addressId: () => Promise<Int>;
  created: () => Promise<DateTimeOutput>;
  deleted: () => Promise<Boolean>;
  name: () => Promise<String>;
  seat: () => Promise<String>;
  structureId: () => Promise<Int>;
  updated: () => Promise<DateTimeOutput>;
}

export interface EntitySubscription
  extends Promise<AsyncIterator<Entity>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  addressId: () => Promise<AsyncIterator<Int>>;
  created: () => Promise<AsyncIterator<DateTimeOutput>>;
  deleted: () => Promise<AsyncIterator<Boolean>>;
  name: () => Promise<AsyncIterator<String>>;
  seat: () => Promise<AsyncIterator<String>>;
  structureId: () => Promise<AsyncIterator<Int>>;
  updated: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface EntityNullablePromise
  extends Promise<Entity | null>,
    Fragmentable {
  id: () => Promise<Int>;
  addressId: () => Promise<Int>;
  created: () => Promise<DateTimeOutput>;
  deleted: () => Promise<Boolean>;
  name: () => Promise<String>;
  seat: () => Promise<String>;
  structureId: () => Promise<Int>;
  updated: () => Promise<DateTimeOutput>;
}

export interface EntityConnection {
  pageInfo: PageInfo;
  edges: EntityEdge[];
}

export interface EntityConnectionPromise
  extends Promise<EntityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EntityEdge>>() => T;
  aggregate: <T = AggregateEntityPromise>() => T;
}

export interface EntityConnectionSubscription
  extends Promise<AsyncIterator<EntityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EntityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEntitySubscription>() => T;
}

export interface EntityEdge {
  node: Entity;
  cursor: String;
}

export interface EntityEdgePromise extends Promise<EntityEdge>, Fragmentable {
  node: <T = EntityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EntityEdgeSubscription
  extends Promise<AsyncIterator<EntityEdge>>,
    Fragmentable {
  node: <T = EntitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEntity {
  count: Int;
}

export interface AggregateEntityPromise
  extends Promise<AggregateEntity>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEntitySubscription
  extends Promise<AsyncIterator<AggregateEntity>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface File {
  id: Int;
  messageId: Int;
  nom: String;
}

export interface FilePromise extends Promise<File>, Fragmentable {
  id: () => Promise<Int>;
  messageId: () => Promise<Int>;
  nom: () => Promise<String>;
}

export interface FileSubscription
  extends Promise<AsyncIterator<File>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  messageId: () => Promise<AsyncIterator<Int>>;
  nom: () => Promise<AsyncIterator<String>>;
}

export interface FileNullablePromise
  extends Promise<File | null>,
    Fragmentable {
  id: () => Promise<Int>;
  messageId: () => Promise<Int>;
  nom: () => Promise<String>;
}

export interface FileConnection {
  pageInfo: PageInfo;
  edges: FileEdge[];
}

export interface FileConnectionPromise
  extends Promise<FileConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FileEdge>>() => T;
  aggregate: <T = AggregateFilePromise>() => T;
}

export interface FileConnectionSubscription
  extends Promise<AsyncIterator<FileConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FileEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFileSubscription>() => T;
}

export interface FileEdge {
  node: File;
  cursor: String;
}

export interface FileEdgePromise extends Promise<FileEdge>, Fragmentable {
  node: <T = FilePromise>() => T;
  cursor: () => Promise<String>;
}

export interface FileEdgeSubscription
  extends Promise<AsyncIterator<FileEdge>>,
    Fragmentable {
  node: <T = FileSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateFile {
  count: Int;
}

export interface AggregateFilePromise
  extends Promise<AggregateFile>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFileSubscription
  extends Promise<AsyncIterator<AggregateFile>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Job {
  id: Int;
  created: DateTimeOutput;
  deleted?: Boolean;
  description: String;
  keyword: String;
  maxSalary: Float;
  minSalary: Float;
  title: String;
  updated: DateTimeOutput;
}

export interface JobPromise extends Promise<Job>, Fragmentable {
  id: () => Promise<Int>;
  created: () => Promise<DateTimeOutput>;
  deleted: () => Promise<Boolean>;
  description: () => Promise<String>;
  keyword: () => Promise<String>;
  maxSalary: () => Promise<Float>;
  minSalary: () => Promise<Float>;
  title: () => Promise<String>;
  updated: () => Promise<DateTimeOutput>;
}

export interface JobSubscription
  extends Promise<AsyncIterator<Job>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  created: () => Promise<AsyncIterator<DateTimeOutput>>;
  deleted: () => Promise<AsyncIterator<Boolean>>;
  description: () => Promise<AsyncIterator<String>>;
  keyword: () => Promise<AsyncIterator<String>>;
  maxSalary: () => Promise<AsyncIterator<Float>>;
  minSalary: () => Promise<AsyncIterator<Float>>;
  title: () => Promise<AsyncIterator<String>>;
  updated: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface JobNullablePromise extends Promise<Job | null>, Fragmentable {
  id: () => Promise<Int>;
  created: () => Promise<DateTimeOutput>;
  deleted: () => Promise<Boolean>;
  description: () => Promise<String>;
  keyword: () => Promise<String>;
  maxSalary: () => Promise<Float>;
  minSalary: () => Promise<Float>;
  title: () => Promise<String>;
  updated: () => Promise<DateTimeOutput>;
}

export interface JobConnection {
  pageInfo: PageInfo;
  edges: JobEdge[];
}

export interface JobConnectionPromise
  extends Promise<JobConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<JobEdge>>() => T;
  aggregate: <T = AggregateJobPromise>() => T;
}

export interface JobConnectionSubscription
  extends Promise<AsyncIterator<JobConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<JobEdgeSubscription>>>() => T;
  aggregate: <T = AggregateJobSubscription>() => T;
}

export interface JobEdge {
  node: Job;
  cursor: String;
}

export interface JobEdgePromise extends Promise<JobEdge>, Fragmentable {
  node: <T = JobPromise>() => T;
  cursor: () => Promise<String>;
}

export interface JobEdgeSubscription
  extends Promise<AsyncIterator<JobEdge>>,
    Fragmentable {
  node: <T = JobSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateJob {
  count: Int;
}

export interface AggregateJobPromise
  extends Promise<AggregateJob>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateJobSubscription
  extends Promise<AsyncIterator<AggregateJob>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LegalType {
  id: Int;
  code?: String;
  created: DateTimeOutput;
  name: String;
}

export interface LegalTypePromise extends Promise<LegalType>, Fragmentable {
  id: () => Promise<Int>;
  code: () => Promise<String>;
  created: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
}

export interface LegalTypeSubscription
  extends Promise<AsyncIterator<LegalType>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  code: () => Promise<AsyncIterator<String>>;
  created: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface LegalTypeNullablePromise
  extends Promise<LegalType | null>,
    Fragmentable {
  id: () => Promise<Int>;
  code: () => Promise<String>;
  created: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
}

export interface LegalTypeConnection {
  pageInfo: PageInfo;
  edges: LegalTypeEdge[];
}

export interface LegalTypeConnectionPromise
  extends Promise<LegalTypeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LegalTypeEdge>>() => T;
  aggregate: <T = AggregateLegalTypePromise>() => T;
}

export interface LegalTypeConnectionSubscription
  extends Promise<AsyncIterator<LegalTypeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LegalTypeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLegalTypeSubscription>() => T;
}

export interface LegalTypeEdge {
  node: LegalType;
  cursor: String;
}

export interface LegalTypeEdgePromise
  extends Promise<LegalTypeEdge>,
    Fragmentable {
  node: <T = LegalTypePromise>() => T;
  cursor: () => Promise<String>;
}

export interface LegalTypeEdgeSubscription
  extends Promise<AsyncIterator<LegalTypeEdge>>,
    Fragmentable {
  node: <T = LegalTypeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateLegalType {
  count: Int;
}

export interface AggregateLegalTypePromise
  extends Promise<AggregateLegalType>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLegalTypeSubscription
  extends Promise<AsyncIterator<AggregateLegalType>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Maction {
  id: Int;
  date: DateTimeOutput;
  deleted: Boolean;
  description?: String;
  effectuePar: String;
  memberId: Int;
  statut: Int;
  titre: String;
}

export interface MactionPromise extends Promise<Maction>, Fragmentable {
  id: () => Promise<Int>;
  date: () => Promise<DateTimeOutput>;
  deleted: () => Promise<Boolean>;
  description: () => Promise<String>;
  effectuePar: () => Promise<String>;
  memberId: () => Promise<Int>;
  statut: () => Promise<Int>;
  titre: () => Promise<String>;
}

export interface MactionSubscription
  extends Promise<AsyncIterator<Maction>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  deleted: () => Promise<AsyncIterator<Boolean>>;
  description: () => Promise<AsyncIterator<String>>;
  effectuePar: () => Promise<AsyncIterator<String>>;
  memberId: () => Promise<AsyncIterator<Int>>;
  statut: () => Promise<AsyncIterator<Int>>;
  titre: () => Promise<AsyncIterator<String>>;
}

export interface MactionNullablePromise
  extends Promise<Maction | null>,
    Fragmentable {
  id: () => Promise<Int>;
  date: () => Promise<DateTimeOutput>;
  deleted: () => Promise<Boolean>;
  description: () => Promise<String>;
  effectuePar: () => Promise<String>;
  memberId: () => Promise<Int>;
  statut: () => Promise<Int>;
  titre: () => Promise<String>;
}

export interface MactionConnection {
  pageInfo: PageInfo;
  edges: MactionEdge[];
}

export interface MactionConnectionPromise
  extends Promise<MactionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MactionEdge>>() => T;
  aggregate: <T = AggregateMactionPromise>() => T;
}

export interface MactionConnectionSubscription
  extends Promise<AsyncIterator<MactionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MactionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMactionSubscription>() => T;
}

export interface MactionEdge {
  node: Maction;
  cursor: String;
}

export interface MactionEdgePromise extends Promise<MactionEdge>, Fragmentable {
  node: <T = MactionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MactionEdgeSubscription
  extends Promise<AsyncIterator<MactionEdge>>,
    Fragmentable {
  node: <T = MactionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMaction {
  count: Int;
}

export interface AggregateMactionPromise
  extends Promise<AggregateMaction>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMactionSubscription
  extends Promise<AsyncIterator<AggregateMaction>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Movement {
  id: Int;
  created: DateTimeOutput;
  date?: DateTimeOutput;
  deleted: Boolean;
  designation: String;
  documentId?: Int;
  htTotal?: Float;
  insertedId?: Int;
  price?: Float;
  quantite?: String;
  structureId: Int;
  ttcTotal: Float;
  tvaId?: Int;
  type: Boolean;
}

export interface MovementPromise extends Promise<Movement>, Fragmentable {
  id: () => Promise<Int>;
  created: () => Promise<DateTimeOutput>;
  date: () => Promise<DateTimeOutput>;
  deleted: () => Promise<Boolean>;
  designation: () => Promise<String>;
  documentId: () => Promise<Int>;
  htTotal: () => Promise<Float>;
  insertedId: () => Promise<Int>;
  price: () => Promise<Float>;
  quantite: () => Promise<String>;
  structureId: () => Promise<Int>;
  ttcTotal: () => Promise<Float>;
  tvaId: () => Promise<Int>;
  type: () => Promise<Boolean>;
}

export interface MovementSubscription
  extends Promise<AsyncIterator<Movement>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  created: () => Promise<AsyncIterator<DateTimeOutput>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  deleted: () => Promise<AsyncIterator<Boolean>>;
  designation: () => Promise<AsyncIterator<String>>;
  documentId: () => Promise<AsyncIterator<Int>>;
  htTotal: () => Promise<AsyncIterator<Float>>;
  insertedId: () => Promise<AsyncIterator<Int>>;
  price: () => Promise<AsyncIterator<Float>>;
  quantite: () => Promise<AsyncIterator<String>>;
  structureId: () => Promise<AsyncIterator<Int>>;
  ttcTotal: () => Promise<AsyncIterator<Float>>;
  tvaId: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<Boolean>>;
}

export interface MovementNullablePromise
  extends Promise<Movement | null>,
    Fragmentable {
  id: () => Promise<Int>;
  created: () => Promise<DateTimeOutput>;
  date: () => Promise<DateTimeOutput>;
  deleted: () => Promise<Boolean>;
  designation: () => Promise<String>;
  documentId: () => Promise<Int>;
  htTotal: () => Promise<Float>;
  insertedId: () => Promise<Int>;
  price: () => Promise<Float>;
  quantite: () => Promise<String>;
  structureId: () => Promise<Int>;
  ttcTotal: () => Promise<Float>;
  tvaId: () => Promise<Int>;
  type: () => Promise<Boolean>;
}

export interface MovementConnection {
  pageInfo: PageInfo;
  edges: MovementEdge[];
}

export interface MovementConnectionPromise
  extends Promise<MovementConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MovementEdge>>() => T;
  aggregate: <T = AggregateMovementPromise>() => T;
}

export interface MovementConnectionSubscription
  extends Promise<AsyncIterator<MovementConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MovementEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMovementSubscription>() => T;
}

export interface MovementEdge {
  node: Movement;
  cursor: String;
}

export interface MovementEdgePromise
  extends Promise<MovementEdge>,
    Fragmentable {
  node: <T = MovementPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MovementEdgeSubscription
  extends Promise<AsyncIterator<MovementEdge>>,
    Fragmentable {
  node: <T = MovementSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMovement {
  count: Int;
}

export interface AggregateMovementPromise
  extends Promise<AggregateMovement>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMovementSubscription
  extends Promise<AsyncIterator<AggregateMovement>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PersonConnection {
  pageInfo: PageInfo;
  edges: PersonEdge[];
}

export interface PersonConnectionPromise
  extends Promise<PersonConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PersonEdge>>() => T;
  aggregate: <T = AggregatePersonPromise>() => T;
}

export interface PersonConnectionSubscription
  extends Promise<AsyncIterator<PersonConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PersonEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePersonSubscription>() => T;
}

export interface PersonEdge {
  node: Person;
  cursor: String;
}

export interface PersonEdgePromise extends Promise<PersonEdge>, Fragmentable {
  node: <T = PersonPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PersonEdgeSubscription
  extends Promise<AsyncIterator<PersonEdge>>,
    Fragmentable {
  node: <T = PersonSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePerson {
  count: Int;
}

export interface AggregatePersonPromise
  extends Promise<AggregatePerson>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePersonSubscription
  extends Promise<AsyncIterator<AggregatePerson>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StructureConnection {
  pageInfo: PageInfo;
  edges: StructureEdge[];
}

export interface StructureConnectionPromise
  extends Promise<StructureConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StructureEdge>>() => T;
  aggregate: <T = AggregateStructurePromise>() => T;
}

export interface StructureConnectionSubscription
  extends Promise<AsyncIterator<StructureConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StructureEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStructureSubscription>() => T;
}

export interface StructureEdge {
  node: Structure;
  cursor: String;
}

export interface StructureEdgePromise
  extends Promise<StructureEdge>,
    Fragmentable {
  node: <T = StructurePromise>() => T;
  cursor: () => Promise<String>;
}

export interface StructureEdgeSubscription
  extends Promise<AsyncIterator<StructureEdge>>,
    Fragmentable {
  node: <T = StructureSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStructure {
  count: Int;
}

export interface AggregateStructurePromise
  extends Promise<AggregateStructure>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStructureSubscription
  extends Promise<AsyncIterator<AggregateStructure>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface User {
  id: Int;
  email: String;
  nom?: String;
  prenom?: String;
  password: String;
  telephone?: String;
  telephone2?: String;
  ville?: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<Int>;
  email: () => Promise<String>;
  nom: () => Promise<String>;
  prenom: () => Promise<String>;
  password: () => Promise<String>;
  telephone: () => Promise<String>;
  telephone2: () => Promise<String>;
  ville: () => Promise<String>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  email: () => Promise<AsyncIterator<String>>;
  nom: () => Promise<AsyncIterator<String>>;
  prenom: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  telephone: () => Promise<AsyncIterator<String>>;
  telephone2: () => Promise<AsyncIterator<String>>;
  ville: () => Promise<AsyncIterator<String>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<Int>;
  email: () => Promise<String>;
  nom: () => Promise<String>;
  prenom: () => Promise<String>;
  password: () => Promise<String>;
  telephone: () => Promise<String>;
  telephone2: () => Promise<String>;
  ville: () => Promise<String>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ClientSubscriptionPayload {
  mutation: MutationType;
  node: Client;
  updatedFields: String[];
  previousValues: ClientPreviousValues;
}

export interface ClientSubscriptionPayloadPromise
  extends Promise<ClientSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ClientPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ClientPreviousValuesPromise>() => T;
}

export interface ClientSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ClientSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ClientSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ClientPreviousValuesSubscription>() => T;
}

export interface ClientPreviousValues {
  id: Int;
  type?: Boolean;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface ClientPreviousValuesPromise
  extends Promise<ClientPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  type: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ClientPreviousValuesSubscription
  extends Promise<AsyncIterator<ClientPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ContactSubscriptionPayload {
  mutation: MutationType;
  node: Contact;
  updatedFields: String[];
  previousValues: ContactPreviousValues;
}

export interface ContactSubscriptionPayloadPromise
  extends Promise<ContactSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ContactPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ContactPreviousValuesPromise>() => T;
}

export interface ContactSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ContactSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ContactSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ContactPreviousValuesSubscription>() => T;
}

export interface ContactPreviousValues {
  id: Int;
  activite?: String;
  adresse?: String;
  adresseComplement?: String;
  civilite: Boolean;
  comment?: String;
  companyName?: String;
  countryId: Int;
  cp?: String;
  created?: DateTimeOutput;
  email?: String;
  insertedId?: Int;
  lienSite?: String;
  nom: String;
  prenom?: String;
  structureId?: Int;
  tel1?: String;
  tel2?: String;
  ville?: String;
}

export interface ContactPreviousValuesPromise
  extends Promise<ContactPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  activite: () => Promise<String>;
  adresse: () => Promise<String>;
  adresseComplement: () => Promise<String>;
  civilite: () => Promise<Boolean>;
  comment: () => Promise<String>;
  companyName: () => Promise<String>;
  countryId: () => Promise<Int>;
  cp: () => Promise<String>;
  created: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  insertedId: () => Promise<Int>;
  lienSite: () => Promise<String>;
  nom: () => Promise<String>;
  prenom: () => Promise<String>;
  structureId: () => Promise<Int>;
  tel1: () => Promise<String>;
  tel2: () => Promise<String>;
  ville: () => Promise<String>;
}

export interface ContactPreviousValuesSubscription
  extends Promise<AsyncIterator<ContactPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  activite: () => Promise<AsyncIterator<String>>;
  adresse: () => Promise<AsyncIterator<String>>;
  adresseComplement: () => Promise<AsyncIterator<String>>;
  civilite: () => Promise<AsyncIterator<Boolean>>;
  comment: () => Promise<AsyncIterator<String>>;
  companyName: () => Promise<AsyncIterator<String>>;
  countryId: () => Promise<AsyncIterator<Int>>;
  cp: () => Promise<AsyncIterator<String>>;
  created: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  insertedId: () => Promise<AsyncIterator<Int>>;
  lienSite: () => Promise<AsyncIterator<String>>;
  nom: () => Promise<AsyncIterator<String>>;
  prenom: () => Promise<AsyncIterator<String>>;
  structureId: () => Promise<AsyncIterator<Int>>;
  tel1: () => Promise<AsyncIterator<String>>;
  tel2: () => Promise<AsyncIterator<String>>;
  ville: () => Promise<AsyncIterator<String>>;
}

export interface CountrySubscriptionPayload {
  mutation: MutationType;
  node: Country;
  updatedFields: String[];
  previousValues: CountryPreviousValues;
}

export interface CountrySubscriptionPayloadPromise
  extends Promise<CountrySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CountryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CountryPreviousValuesPromise>() => T;
}

export interface CountrySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CountrySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CountrySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CountryPreviousValuesSubscription>() => T;
}

export interface CountryPreviousValues {
  id: Int;
  code: String;
  name: String;
  ordre: Int;
}

export interface CountryPreviousValuesPromise
  extends Promise<CountryPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  code: () => Promise<String>;
  name: () => Promise<String>;
  ordre: () => Promise<Int>;
}

export interface CountryPreviousValuesSubscription
  extends Promise<AsyncIterator<CountryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  code: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  ordre: () => Promise<AsyncIterator<Int>>;
}

export interface DepartmentSubscriptionPayload {
  mutation: MutationType;
  node: Department;
  updatedFields: String[];
  previousValues: DepartmentPreviousValues;
}

export interface DepartmentSubscriptionPayloadPromise
  extends Promise<DepartmentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DepartmentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DepartmentPreviousValuesPromise>() => T;
}

export interface DepartmentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DepartmentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DepartmentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DepartmentPreviousValuesSubscription>() => T;
}

export interface DepartmentPreviousValues {
  id: Int;
  created: DateTimeOutput;
  deleted: Boolean;
  location: String;
  managerId: Int;
  name: String;
  structureId: Int;
  updated: DateTimeOutput;
}

export interface DepartmentPreviousValuesPromise
  extends Promise<DepartmentPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  created: () => Promise<DateTimeOutput>;
  deleted: () => Promise<Boolean>;
  location: () => Promise<String>;
  managerId: () => Promise<Int>;
  name: () => Promise<String>;
  structureId: () => Promise<Int>;
  updated: () => Promise<DateTimeOutput>;
}

export interface DepartmentPreviousValuesSubscription
  extends Promise<AsyncIterator<DepartmentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  created: () => Promise<AsyncIterator<DateTimeOutput>>;
  deleted: () => Promise<AsyncIterator<Boolean>>;
  location: () => Promise<AsyncIterator<String>>;
  managerId: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  structureId: () => Promise<AsyncIterator<Int>>;
  updated: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DevisModeleSubscriptionPayload {
  mutation: MutationType;
  node: DevisModele;
  updatedFields: String[];
  previousValues: DevisModelePreviousValues;
}

export interface DevisModeleSubscriptionPayloadPromise
  extends Promise<DevisModeleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DevisModelePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DevisModelePreviousValuesPromise>() => T;
}

export interface DevisModeleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DevisModeleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DevisModeleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DevisModelePreviousValuesSubscription>() => T;
}

export interface DevisModelePreviousValues {
  id: Int;
  adresseId?: Int;
  created: DateTimeOutput;
  deleted: Boolean;
  modele?: String;
  name: String;
  structureId: Int;
  texteBas: String;
  updated?: DateTimeOutput;
}

export interface DevisModelePreviousValuesPromise
  extends Promise<DevisModelePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  adresseId: () => Promise<Int>;
  created: () => Promise<DateTimeOutput>;
  deleted: () => Promise<Boolean>;
  modele: () => Promise<String>;
  name: () => Promise<String>;
  structureId: () => Promise<Int>;
  texteBas: () => Promise<String>;
  updated: () => Promise<DateTimeOutput>;
}

export interface DevisModelePreviousValuesSubscription
  extends Promise<AsyncIterator<DevisModelePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  adresseId: () => Promise<AsyncIterator<Int>>;
  created: () => Promise<AsyncIterator<DateTimeOutput>>;
  deleted: () => Promise<AsyncIterator<Boolean>>;
  modele: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  structureId: () => Promise<AsyncIterator<Int>>;
  texteBas: () => Promise<AsyncIterator<String>>;
  updated: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DocumentSubscriptionPayload {
  mutation: MutationType;
  node: Document;
  updatedFields: String[];
  previousValues: DocumentPreviousValues;
}

export interface DocumentSubscriptionPayloadPromise
  extends Promise<DocumentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DocumentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DocumentPreviousValuesPromise>() => T;
}

export interface DocumentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DocumentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DocumentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DocumentPreviousValuesSubscription>() => T;
}

export interface DocumentPreviousValues {
  id: Int;
  commentaire?: String;
  created: DateTimeOutput;
  dateEmission?: DateTimeOutput;
  deleted: Boolean;
  documentTypeId: Int;
  entityId: Int;
  file: String;
  insertedId?: Int;
  name: String;
  public: Boolean;
  structureId: Int;
  updated?: DateTimeOutput;
  verEdition: Boolean;
}

export interface DocumentPreviousValuesPromise
  extends Promise<DocumentPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  commentaire: () => Promise<String>;
  created: () => Promise<DateTimeOutput>;
  dateEmission: () => Promise<DateTimeOutput>;
  deleted: () => Promise<Boolean>;
  documentTypeId: () => Promise<Int>;
  entityId: () => Promise<Int>;
  file: () => Promise<String>;
  insertedId: () => Promise<Int>;
  name: () => Promise<String>;
  public: () => Promise<Boolean>;
  structureId: () => Promise<Int>;
  updated: () => Promise<DateTimeOutput>;
  verEdition: () => Promise<Boolean>;
}

export interface DocumentPreviousValuesSubscription
  extends Promise<AsyncIterator<DocumentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  commentaire: () => Promise<AsyncIterator<String>>;
  created: () => Promise<AsyncIterator<DateTimeOutput>>;
  dateEmission: () => Promise<AsyncIterator<DateTimeOutput>>;
  deleted: () => Promise<AsyncIterator<Boolean>>;
  documentTypeId: () => Promise<AsyncIterator<Int>>;
  entityId: () => Promise<AsyncIterator<Int>>;
  file: () => Promise<AsyncIterator<String>>;
  insertedId: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  public: () => Promise<AsyncIterator<Boolean>>;
  structureId: () => Promise<AsyncIterator<Int>>;
  updated: () => Promise<AsyncIterator<DateTimeOutput>>;
  verEdition: () => Promise<AsyncIterator<Boolean>>;
}

export interface DocumentTypeSubscriptionPayload {
  mutation: MutationType;
  node: DocumentType;
  updatedFields: String[];
  previousValues: DocumentTypePreviousValues;
}

export interface DocumentTypeSubscriptionPayloadPromise
  extends Promise<DocumentTypeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DocumentTypePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DocumentTypePreviousValuesPromise>() => T;
}

export interface DocumentTypeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DocumentTypeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DocumentTypeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DocumentTypePreviousValuesSubscription>() => T;
}

export interface DocumentTypePreviousValues {
  id: Int;
  title: String;
}

export interface DocumentTypePreviousValuesPromise
  extends Promise<DocumentTypePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  title: () => Promise<String>;
}

export interface DocumentTypePreviousValuesSubscription
  extends Promise<AsyncIterator<DocumentTypePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  title: () => Promise<AsyncIterator<String>>;
}

export interface EmpInfoSubscriptionPayload {
  mutation: MutationType;
  node: EmpInfo;
  updatedFields: String[];
  previousValues: EmpInfoPreviousValues;
}

export interface EmpInfoSubscriptionPayloadPromise
  extends Promise<EmpInfoSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EmpInfoPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EmpInfoPreviousValuesPromise>() => T;
}

export interface EmpInfoSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EmpInfoSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EmpInfoSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EmpInfoPreviousValuesSubscription>() => T;
}

export interface EmpInfoPreviousValues {
  id: Int;
  compteBancaire?: String;
  created?: DateTimeOutput;
  deleted?: Boolean;
  nbreEnfants?: Int;
  numCimr?: String;
  numCnss?: String;
  numMutuelle?: String;
  numPasseport?: String;
  situationFamiliale?: Int;
  updated?: DateTimeOutput;
}

export interface EmpInfoPreviousValuesPromise
  extends Promise<EmpInfoPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  compteBancaire: () => Promise<String>;
  created: () => Promise<DateTimeOutput>;
  deleted: () => Promise<Boolean>;
  nbreEnfants: () => Promise<Int>;
  numCimr: () => Promise<String>;
  numCnss: () => Promise<String>;
  numMutuelle: () => Promise<String>;
  numPasseport: () => Promise<String>;
  situationFamiliale: () => Promise<Int>;
  updated: () => Promise<DateTimeOutput>;
}

export interface EmpInfoPreviousValuesSubscription
  extends Promise<AsyncIterator<EmpInfoPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  compteBancaire: () => Promise<AsyncIterator<String>>;
  created: () => Promise<AsyncIterator<DateTimeOutput>>;
  deleted: () => Promise<AsyncIterator<Boolean>>;
  nbreEnfants: () => Promise<AsyncIterator<Int>>;
  numCimr: () => Promise<AsyncIterator<String>>;
  numCnss: () => Promise<AsyncIterator<String>>;
  numMutuelle: () => Promise<AsyncIterator<String>>;
  numPasseport: () => Promise<AsyncIterator<String>>;
  situationFamiliale: () => Promise<AsyncIterator<Int>>;
  updated: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface EmployeSubscriptionPayload {
  mutation: MutationType;
  node: Employe;
  updatedFields: String[];
  previousValues: EmployePreviousValues;
}

export interface EmployeSubscriptionPayloadPromise
  extends Promise<EmployeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EmployePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EmployePreviousValuesPromise>() => T;
}

export interface EmployeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EmployeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EmployeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EmployePreviousValuesSubscription>() => T;
}

export interface EmployePreviousValues {
  id: Int;
  email?: String;
  adresseId?: Int;
  code?: String;
  created: DateTimeOutput;
  deleted?: Boolean;
  departmentId?: Int;
  empInfoId?: Int;
  firstname: String;
  gender?: Int;
  hireDate?: DateTimeOutput;
  jobId?: Int;
  lastname: String;
  managerId?: Int;
  phone1?: String;
  phone2?: String;
  salary?: Float;
  structureId?: Int;
  type?: Boolean;
  updated?: DateTimeOutput;
}

export interface EmployePreviousValuesPromise
  extends Promise<EmployePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  email: () => Promise<String>;
  adresseId: () => Promise<Int>;
  code: () => Promise<String>;
  created: () => Promise<DateTimeOutput>;
  deleted: () => Promise<Boolean>;
  departmentId: () => Promise<Int>;
  empInfoId: () => Promise<Int>;
  firstname: () => Promise<String>;
  gender: () => Promise<Int>;
  hireDate: () => Promise<DateTimeOutput>;
  jobId: () => Promise<Int>;
  lastname: () => Promise<String>;
  managerId: () => Promise<Int>;
  phone1: () => Promise<String>;
  phone2: () => Promise<String>;
  salary: () => Promise<Float>;
  structureId: () => Promise<Int>;
  type: () => Promise<Boolean>;
  updated: () => Promise<DateTimeOutput>;
}

export interface EmployePreviousValuesSubscription
  extends Promise<AsyncIterator<EmployePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  email: () => Promise<AsyncIterator<String>>;
  adresseId: () => Promise<AsyncIterator<Int>>;
  code: () => Promise<AsyncIterator<String>>;
  created: () => Promise<AsyncIterator<DateTimeOutput>>;
  deleted: () => Promise<AsyncIterator<Boolean>>;
  departmentId: () => Promise<AsyncIterator<Int>>;
  empInfoId: () => Promise<AsyncIterator<Int>>;
  firstname: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<Int>>;
  hireDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  jobId: () => Promise<AsyncIterator<Int>>;
  lastname: () => Promise<AsyncIterator<String>>;
  managerId: () => Promise<AsyncIterator<Int>>;
  phone1: () => Promise<AsyncIterator<String>>;
  phone2: () => Promise<AsyncIterator<String>>;
  salary: () => Promise<AsyncIterator<Float>>;
  structureId: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<Boolean>>;
  updated: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface EntitySubscriptionPayload {
  mutation: MutationType;
  node: Entity;
  updatedFields: String[];
  previousValues: EntityPreviousValues;
}

export interface EntitySubscriptionPayloadPromise
  extends Promise<EntitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EntityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EntityPreviousValuesPromise>() => T;
}

export interface EntitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EntitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EntitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EntityPreviousValuesSubscription>() => T;
}

export interface EntityPreviousValues {
  id: Int;
  addressId: Int;
  created: DateTimeOutput;
  deleted: Boolean;
  name: String;
  seat: String;
  structureId: Int;
  updated?: DateTimeOutput;
}

export interface EntityPreviousValuesPromise
  extends Promise<EntityPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  addressId: () => Promise<Int>;
  created: () => Promise<DateTimeOutput>;
  deleted: () => Promise<Boolean>;
  name: () => Promise<String>;
  seat: () => Promise<String>;
  structureId: () => Promise<Int>;
  updated: () => Promise<DateTimeOutput>;
}

export interface EntityPreviousValuesSubscription
  extends Promise<AsyncIterator<EntityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  addressId: () => Promise<AsyncIterator<Int>>;
  created: () => Promise<AsyncIterator<DateTimeOutput>>;
  deleted: () => Promise<AsyncIterator<Boolean>>;
  name: () => Promise<AsyncIterator<String>>;
  seat: () => Promise<AsyncIterator<String>>;
  structureId: () => Promise<AsyncIterator<Int>>;
  updated: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FileSubscriptionPayload {
  mutation: MutationType;
  node: File;
  updatedFields: String[];
  previousValues: FilePreviousValues;
}

export interface FileSubscriptionPayloadPromise
  extends Promise<FileSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FilePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FilePreviousValuesPromise>() => T;
}

export interface FileSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FileSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FileSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FilePreviousValuesSubscription>() => T;
}

export interface FilePreviousValues {
  id: Int;
  messageId: Int;
  nom: String;
}

export interface FilePreviousValuesPromise
  extends Promise<FilePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  messageId: () => Promise<Int>;
  nom: () => Promise<String>;
}

export interface FilePreviousValuesSubscription
  extends Promise<AsyncIterator<FilePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  messageId: () => Promise<AsyncIterator<Int>>;
  nom: () => Promise<AsyncIterator<String>>;
}

export interface JobSubscriptionPayload {
  mutation: MutationType;
  node: Job;
  updatedFields: String[];
  previousValues: JobPreviousValues;
}

export interface JobSubscriptionPayloadPromise
  extends Promise<JobSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = JobPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = JobPreviousValuesPromise>() => T;
}

export interface JobSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<JobSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = JobSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = JobPreviousValuesSubscription>() => T;
}

export interface JobPreviousValues {
  id: Int;
  created: DateTimeOutput;
  deleted?: Boolean;
  description: String;
  keyword: String;
  maxSalary: Float;
  minSalary: Float;
  title: String;
  updated: DateTimeOutput;
}

export interface JobPreviousValuesPromise
  extends Promise<JobPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  created: () => Promise<DateTimeOutput>;
  deleted: () => Promise<Boolean>;
  description: () => Promise<String>;
  keyword: () => Promise<String>;
  maxSalary: () => Promise<Float>;
  minSalary: () => Promise<Float>;
  title: () => Promise<String>;
  updated: () => Promise<DateTimeOutput>;
}

export interface JobPreviousValuesSubscription
  extends Promise<AsyncIterator<JobPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  created: () => Promise<AsyncIterator<DateTimeOutput>>;
  deleted: () => Promise<AsyncIterator<Boolean>>;
  description: () => Promise<AsyncIterator<String>>;
  keyword: () => Promise<AsyncIterator<String>>;
  maxSalary: () => Promise<AsyncIterator<Float>>;
  minSalary: () => Promise<AsyncIterator<Float>>;
  title: () => Promise<AsyncIterator<String>>;
  updated: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface LegalTypeSubscriptionPayload {
  mutation: MutationType;
  node: LegalType;
  updatedFields: String[];
  previousValues: LegalTypePreviousValues;
}

export interface LegalTypeSubscriptionPayloadPromise
  extends Promise<LegalTypeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LegalTypePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LegalTypePreviousValuesPromise>() => T;
}

export interface LegalTypeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LegalTypeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LegalTypeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LegalTypePreviousValuesSubscription>() => T;
}

export interface LegalTypePreviousValues {
  id: Int;
  code?: String;
  created: DateTimeOutput;
  name: String;
}

export interface LegalTypePreviousValuesPromise
  extends Promise<LegalTypePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  code: () => Promise<String>;
  created: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
}

export interface LegalTypePreviousValuesSubscription
  extends Promise<AsyncIterator<LegalTypePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  code: () => Promise<AsyncIterator<String>>;
  created: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface MactionSubscriptionPayload {
  mutation: MutationType;
  node: Maction;
  updatedFields: String[];
  previousValues: MactionPreviousValues;
}

export interface MactionSubscriptionPayloadPromise
  extends Promise<MactionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MactionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MactionPreviousValuesPromise>() => T;
}

export interface MactionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MactionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MactionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MactionPreviousValuesSubscription>() => T;
}

export interface MactionPreviousValues {
  id: Int;
  date: DateTimeOutput;
  deleted: Boolean;
  description?: String;
  effectuePar: String;
  memberId: Int;
  statut: Int;
  titre: String;
}

export interface MactionPreviousValuesPromise
  extends Promise<MactionPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  date: () => Promise<DateTimeOutput>;
  deleted: () => Promise<Boolean>;
  description: () => Promise<String>;
  effectuePar: () => Promise<String>;
  memberId: () => Promise<Int>;
  statut: () => Promise<Int>;
  titre: () => Promise<String>;
}

export interface MactionPreviousValuesSubscription
  extends Promise<AsyncIterator<MactionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  deleted: () => Promise<AsyncIterator<Boolean>>;
  description: () => Promise<AsyncIterator<String>>;
  effectuePar: () => Promise<AsyncIterator<String>>;
  memberId: () => Promise<AsyncIterator<Int>>;
  statut: () => Promise<AsyncIterator<Int>>;
  titre: () => Promise<AsyncIterator<String>>;
}

export interface MovementSubscriptionPayload {
  mutation: MutationType;
  node: Movement;
  updatedFields: String[];
  previousValues: MovementPreviousValues;
}

export interface MovementSubscriptionPayloadPromise
  extends Promise<MovementSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MovementPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MovementPreviousValuesPromise>() => T;
}

export interface MovementSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MovementSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MovementSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MovementPreviousValuesSubscription>() => T;
}

export interface MovementPreviousValues {
  id: Int;
  created: DateTimeOutput;
  date?: DateTimeOutput;
  deleted: Boolean;
  designation: String;
  documentId?: Int;
  htTotal?: Float;
  insertedId?: Int;
  price?: Float;
  quantite?: String;
  structureId: Int;
  ttcTotal: Float;
  tvaId?: Int;
  type: Boolean;
}

export interface MovementPreviousValuesPromise
  extends Promise<MovementPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  created: () => Promise<DateTimeOutput>;
  date: () => Promise<DateTimeOutput>;
  deleted: () => Promise<Boolean>;
  designation: () => Promise<String>;
  documentId: () => Promise<Int>;
  htTotal: () => Promise<Float>;
  insertedId: () => Promise<Int>;
  price: () => Promise<Float>;
  quantite: () => Promise<String>;
  structureId: () => Promise<Int>;
  ttcTotal: () => Promise<Float>;
  tvaId: () => Promise<Int>;
  type: () => Promise<Boolean>;
}

export interface MovementPreviousValuesSubscription
  extends Promise<AsyncIterator<MovementPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  created: () => Promise<AsyncIterator<DateTimeOutput>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  deleted: () => Promise<AsyncIterator<Boolean>>;
  designation: () => Promise<AsyncIterator<String>>;
  documentId: () => Promise<AsyncIterator<Int>>;
  htTotal: () => Promise<AsyncIterator<Float>>;
  insertedId: () => Promise<AsyncIterator<Int>>;
  price: () => Promise<AsyncIterator<Float>>;
  quantite: () => Promise<AsyncIterator<String>>;
  structureId: () => Promise<AsyncIterator<Int>>;
  ttcTotal: () => Promise<AsyncIterator<Float>>;
  tvaId: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<Boolean>>;
}

export interface PersonSubscriptionPayload {
  mutation: MutationType;
  node: Person;
  updatedFields: String[];
  previousValues: PersonPreviousValues;
}

export interface PersonSubscriptionPayloadPromise
  extends Promise<PersonSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PersonPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PersonPreviousValuesPromise>() => T;
}

export interface PersonSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PersonSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PersonSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PersonPreviousValuesSubscription>() => T;
}

export interface PersonPreviousValues {
  id: Int;
  firstname?: String;
  lastname?: String;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface PersonPreviousValuesPromise
  extends Promise<PersonPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  firstname: () => Promise<String>;
  lastname: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PersonPreviousValuesSubscription
  extends Promise<AsyncIterator<PersonPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  firstname: () => Promise<AsyncIterator<String>>;
  lastname: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface StructureSubscriptionPayload {
  mutation: MutationType;
  node: Structure;
  updatedFields: String[];
  previousValues: StructurePreviousValues;
}

export interface StructureSubscriptionPayloadPromise
  extends Promise<StructureSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StructurePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StructurePreviousValuesPromise>() => T;
}

export interface StructureSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StructureSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StructureSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StructurePreviousValuesSubscription>() => T;
}

export interface StructurePreviousValues {
  id: Int;
  raison_sociale?: String;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface StructurePreviousValuesPromise
  extends Promise<StructurePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  raison_sociale: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface StructurePreviousValuesSubscription
  extends Promise<AsyncIterator<StructurePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  raison_sociale: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: Int;
  email: String;
  nom?: String;
  prenom?: String;
  password: String;
  telephone?: String;
  telephone2?: String;
  ville?: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  email: () => Promise<String>;
  nom: () => Promise<String>;
  prenom: () => Promise<String>;
  password: () => Promise<String>;
  telephone: () => Promise<String>;
  telephone2: () => Promise<String>;
  ville: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  email: () => Promise<AsyncIterator<String>>;
  nom: () => Promise<AsyncIterator<String>>;
  prenom: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  telephone: () => Promise<AsyncIterator<String>>;
  telephone2: () => Promise<AsyncIterator<String>>;
  ville: () => Promise<AsyncIterator<String>>;
}

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Employe",
    embedded: false
  },
  {
    name: "Client",
    embedded: false
  },
  {
    name: "Person",
    embedded: false
  },
  {
    name: "Structure",
    embedded: false
  },
  {
    name: "Contact",
    embedded: false
  },
  {
    name: "Country",
    embedded: false
  },
  {
    name: "Department",
    embedded: false
  },
  {
    name: "DevisModele",
    embedded: false
  },
  {
    name: "Document",
    embedded: false
  },
  {
    name: "DocumentType",
    embedded: false
  },
  {
    name: "EmpInfo",
    embedded: false
  },
  {
    name: "Entity",
    embedded: false
  },
  {
    name: "File",
    embedded: false
  },
  {
    name: "Job",
    embedded: false
  },
  {
    name: "LegalType",
    embedded: false
  },
  {
    name: "Maction",
    embedded: false
  },
  {
    name: "Movement",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
