directive @isAdmin on FIELD_DEFINITION

scalar DateTime

type Query {
  hello: String
  me: User
  user(id:ID!): User
  users(where: UserWhereInput, orderBy:UserOrderByInput, page: Int, limit: Int): UserConnection!
  
  car(id:ID!): Car
  cars(where: CarWhereInput, orderBy:CarOrderByInput, page: Int, limit: Int): CarConnection!
  
  customer(id:ID!): Customer
  customers(where: CustomerWhereInput, orderBy:CustomerOrderByInput, page: Int, limit: Int): CustomerConnection!
  
  booking(id:ID!): Booking
  bookings(where: BookingWhereInput, orderBy:BookingOrderByInput, page: Int, limit: Int): BookingConnection!
}



type Mutation {
	login(email: String!, password: String!): LoginResponse!
	signup(nom:String!, prenom:String, email: String!, password: String!): LoginResponse!
  forgotPassword(email: String!): Response!
  recoverPassword(id: ID!, recover_code:String!, new_password:String!): Response!
  createUser(data:UserInput!): User!
  updateUser(data:UserInput!, id:ID!): User!
  createCustomer(data:CustomerInput!): Customer!
  updateCustomer(data:CustomerInput!, id:ID!): Customer!
  createBooking(data:BookingInput!): Booking!
  updateBooking(data:BookingInput!, id:ID!): Booking!

}
type Response{
  statut_code: Int
  message: String
}
type LoginResponse{
	user: User
	token: String
	statut_code: Int
	message: String
}
type User {
  id: ID!
  firstname: String
  lastname: String
  gender: String
  cni: String
  address: String
  email: String
  phone: String
  roleId: Int
  password: String
}
input UserInput{
  firstname: String!
  lastname: String
  gender: String
  cni: String
  address: String
  email: String!
  phone: String
  roleId: String
  password: String
}
input UserWhereInput{
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}
enum UserOrderByInput {
  id_ASC
  id_DESC
}
type UserConnection {
  edges: [UserEdge!]
  pageInfo: PageInfo!
}
type UserEdge {
  node: User!
  cursor: String!
}
type AggregateUser {
  count: Int!
}

type Car {
  id: ID!
  plate_number: String!
  brandId: Int
  model: String
  model_date: DateTime
  categoryId: Int
  price: Int
  colorId: Int
  chassis_number: String
  statusId: Int
  brand: Brand 
}

input CarInput{
  immatriculation: String!
}
input CarWhereInput{
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  AND: [CarWhereInput!]
  OR: [CarWhereInput!]
  NOT: [CarWhereInput!]
}
enum CarOrderByInput {
  id_ASC
  id_DESC
}
type CarConnection {
  edges: [CarEdge!]
  pageInfo: PageInfo!
}
type CarEdge {
  node: Car!
  cursor: String!
}
type AggregateCar {
  count: Int!
}
type Customer {
  id: ID!
  firstname: String
  lastname: String
  birthday: DateTime
  gender: String
  cni: String
  type: Boolean
  driver_license: String
  city: String
  address: String
  email: String
  phone: String
  company_name: String
}

input CustomerInput{
  firstname: String
  lastname: String
  birthday: DateTime
  gender: String
  cni: String
  type: Boolean
  driver_license: String
  city: String
  address: String
  email: String
  phone: String
  company_name: String
}

input CustomerWhereInput{
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  AND: [CustomerWhereInput!]
  OR: [CustomerWhereInput!]
  NOT: [CustomerWhereInput!]
}

enum CustomerOrderByInput{
  id_ASC
  id_DESC
}

type CustomerConnection{
  edges: [CustomerEdge!]
  pageInfo: PageInfo!
}

type CustomerEdge{
  node: Customer!
  cursor: String!
}

type Booking {
  id: ID!
  carId: Int
  customerId: Int
  date_begin: DateTime
  date_end: DateTime
  hour_begin: DateTime
  hour_end: DateTime
}

input BookingInput{
  carId: Int
  customerId: Int
  date_begin: DateTime
  date_end: DateTime
  hour_begin: DateTime
  hour_end: DateTime
}

input BookingWhereInput{
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  AND: [BookingWhereInput!]
  OR: [BookingWhereInput!]
  NOT: [BookingWhereInput!]
}

enum BookingOrderByInput{
  id_ASC
  id_DESC
}

type BookingConnection{
  edges: [BookingEdge!]
  pageInfo: PageInfo!
}

type BookingEdge{
  node: Booking!
  cursor: String!
}

type PageInfo {
  count: Int
  currentPage: Int
}
