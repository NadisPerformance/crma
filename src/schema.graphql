directive @isAdmin on FIELD_DEFINITION

scalar DateTime
scalar Upload

type Query {
  hello: String
  me: User
  user(id:ID!): User
  users(where: UserWhereInput, orderBy:UserOrderByInput, page: Int, limit: Int): UserConnection!

  car(id:ID!): Car
  cars(where: CarWhereInput, orderBy:CarOrderByInput, page: Int, limit: Int): CarConnection!

  category(id:ID!): Category
  categories(where: CategoryWhereInput, orderBy:CategoryOrderByInput, page: Int, limit: Int): CategoryConnection!

  color(id:ID!): Color
  colors(where: ColorWhereInput, orderBy:ColorOrderByInput, page: Int, limit: Int): ColorConnection!


  customer(id:ID!): Customer
  customers(where: CustomerWhereInput, orderBy:CustomerOrderByInput, page: Int, limit: Int): CustomerConnection!

  booking(id:ID!): Booking
  bookings(where: BookingWhereInput, orderBy:BookingOrderByInput, page: Int, limit: Int): BookingConnection!

  rental(id:ID!): Rental
  rentals(where: RentalWhereInput, orderBy:RentalOrderByInput, page: Int, limit: Int): RentalConnection!

  brand(id:ID!): Brand
  brands(where: BrandWhereInput, orderBy:BrandOrderByInput, page: Int, limit: Int): BrandConnection!

  role(id:ID!): Role
  roles(where: RoleWhereInput, orderBy:RoleOrderByInput, page: Int, limit: Int): RoleConnection!

  image(id:ID!): Image
  images(where: ImageWhereInput, orderBy:ImageOrderByInput, page: Int, limit: Int): ImageConnection!

  status(id:ID!): Status
  statuss(where: StatusWhereInput, orderBy:StatusOrderByInput, page: Int, limit: Int): StatusConnection!

}



type Mutation {
	login(email: String!, password: String!): LoginResponse!
	signup(nom:String!, prenom:String, email: String!, password: String!): LoginResponse!
  forgotPassword(email: String!): Response!
  recoverPassword(id: ID!, recover_code:String!, new_password:String!): Response!
  createUser(data:UserInput!): User!
  updateUser(data:UserInput!, id:ID!): User!
  deleteUser(id:ID!): Response
  createCustomer(data:CustomerInput!): Customer!
  updateCustomer(data:CustomerInput!, id:ID!): Customer!
  deleteCustomer(id:ID!): Response
  createBooking(data:BookingInput!): Booking!
  updateBooking(data:BookingInput!, id:ID!): Booking!
  deleteBooking(id:ID!): Response
  createBrand(data:BrandInput!): Brand!
  updateBrand(data:BrandInput!, id:ID!): Brand!
  deleteBrand(id:ID!): Response
  createRole(data:RoleInput!): Role!
  updateRole(data:RoleInput!, id:ID!): Role!
  deleteRole(id:ID!): Response
  createImage(data:ImageInput!): Image!
  updateImage(data:ImageInput!, id:ID!): Image!
  deleteImage(id:ID!): Response
  createColor(data:ColorInput!): Color!
  updateColor(data:ColorInput!, id:ID!): Color!
  deleteColor(id:ID!): Response
  createCategory(data:CategoryInput!): Category!
  updateCategory(data:CategoryInput!, id:ID!): Category!
  deleteCategory(id:ID!): Response
  createStatus(data:StatusInput!): Status!
  updateStatus(data:StatusInput!, id:ID!): Status!
  deleteStatus(id:ID!): Response
}
type Response{
  statut_code: Int
  message: String
}

type After_rental {
  id: ID!
  rentalId: Int
  albumId: Int
  kilometrage: Int
  niveau_carburant: Int
  createdAt: String
  comment: String

}

input After_rentalInput{
  rentalId: Int
  albumId: Int
  kilometrage: Int
  niveau_carburant: Int
  createdAt: String
  comment: String
}

input After_rentalWhereInput{
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  AND: [After_rentalWhereInput!]
  OR: [After_rentalWhereInput!]
  NOT: [After_rentalWhereInput!]
}

enum After_rentalOrderByInput{
  id_ASC
  id_DESC
}

type After_rentalConnection{
  edges: [After_rentalEdge!]
  pageInfo: PageInfo!
}

type After_rentalEdge{
  node: After_rental!
  cursor: String!
}

type Album {
  id: ID!
  title: String
}

input AlbumInput{
  title: String
}

input AlbumWhereInput{
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  AND: [AlbumWhereInput!]
  OR: [AlbumWhereInput!]
  NOT: [AlbumWhereInput!]
}

enum AlbumOrderByInput{
  id_ASC
  id_DESC
}

type AlbumConnection{
  edges: [AlbumEdge!]
  pageInfo: PageInfo!
}

type AlbumEdge{
  node: Album!
  cursor: String!
}

type Before_rental {
  id: ID!
  rentalId: Int
  albumId: Int
  kilometrage: Int
  niveau_carburant: Int
  createdAt: String
  comment: String

}

input Before_rentalInput{
  rentalId: Int
  albumId: Int
  kilometrage: Int
  niveau_carburant: Int
  createdAt: String
  comment: String
}

input Before_rentalWhereInput{
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  AND: [Before_rentalWhereInput!]
  OR: [Before_rentalWhereInput!]
  NOT: [Before_rentalWhereInput!]
}

enum Before_rentalOrderByInput{
  id_ASC
  id_DESC
}

type Before_rentalConnection{
  edges: [Before_rentalEdge!]
  pageInfo: PageInfo!
}

type Before_rentalEdge{
  node: Before_rental!
  cursor: String!
}

type Bill {
  id: ID!
  rentalId: Int
  albumId: Int
  kilometrage: Int
  niveau_carburant: Int
  createdAt: String
  comment: String

}

input BillInput{
  rentalId: Int
  albumId: Int
  kilometrage: Int
  niveau_carburant: Int
  createdAt: String
  comment: String
}

input BillWhereInput{
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  AND: [BillWhereInput!]
  OR: [BillWhereInput!]
  NOT: [BillWhereInput!]
}

enum BillOrderByInput{
  id_ASC
  id_DESC
}

type BillConnection{
  edges: [BillEdge!]
  pageInfo: PageInfo!
}

type BillEdge{
  node: Bill!
  cursor: String!
}

type Booking {
  id: ID!
  carId: Int
  customerId: Int
  date_begin: DateTime
  date_end: DateTime
  hour_begin: DateTime
  hour_end: DateTime
  car: Car
  customer: Customer
}

input BookingInput{
  carId: Int
  customerId: Int
  date_begin: DateTime
  date_end: DateTime
  hour_begin: DateTime
  hour_end: DateTime
}

input BookingWhereInput{
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  AND: [BookingWhereInput!]
  OR: [BookingWhereInput!]
  NOT: [BookingWhereInput!]
}

enum BookingOrderByInput{
  id_ASC
  id_DESC
}

type BookingConnection{
  edges: [BookingEdge!]
  pageInfo: PageInfo!
}

type BookingEdge{
  node: Booking!
  cursor: String!
}

type Brand {
  id: ID!
  name: String
}

input BrandInput{
  name: String
}

input BrandWhereInput{
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  AND: [BrandWhereInput!]
  OR: [BrandWhereInput!]
  NOT: [BrandWhereInput!]
}

enum BrandOrderByInput{
  id_ASC
  id_DESC
}

type BrandConnection{
  edges: [BrandEdge!]
  pageInfo: PageInfo!
}

type BrandEdge{
  node: Brand!
  cursor: String!
}

type LoginResponse{
	user: User
	token: String
	statut_code: Int
	message: String
}

type Car {
  id: ID!
  plate_number: String!
  brandId: Int
  model: String
  model_date: Int
  categoryId: Int
  price: Int
  colorId: Int
  chassis_number: String
  statusId: Int
  brand: Brand
  category: Category
  color: Color
  status: Status
}

input CarInput{
  plate_number: String!
  brandId: Int
  model: String
  model_date: Int
  categoryId: Int
  price: Int
  colorId: Int
  chassis_number: String
  statusId: Int
}
input CarWhereInput{
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  AND: [CarWhereInput!]
  OR: [CarWhereInput!]
  NOT: [CarWhereInput!]
}
enum CarOrderByInput {
  id_ASC
  id_DESC
}
type CarConnection {
  edges: [CarEdge!]
  pageInfo: PageInfo!
}
type CarEdge {
  node: Car!
  cursor: String!
}
type AggregateCar {
  count: Int!
}

type Category {
  id: ID!
  title: String!
}

input CategoryInput{
  title: String!
}
input CategoryWhereInput{
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  AND: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  NOT: [CategoryWhereInput!]
}
enum CategoryOrderByInput {
  id_ASC
  id_DESC
}
type CategoryConnection {
  edges: [CategoryEdge!]
  pageInfo: PageInfo!
}
type CategoryEdge {
  node: Category!
  cursor: String!
}
type AggregateCategory {
  count: Int!
}
type Color {
  id: ID!
  name: String!
}

input ColorInput{
  name: String!
}
input ColorWhereInput{
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  AND: [ColorWhereInput!]
  OR: [ColorWhereInput!]
  NOT: [ColorWhereInput!]
}
enum ColorOrderByInput {
  id_ASC
  id_DESC
}
type ColorConnection {
  edges: [ColorEdge!]
  pageInfo: PageInfo!
}
type ColorEdge {
  node: Color!
  cursor: String!
}
type AggregateColor {
  count: Int!
}
type Car_insurance {
  id: ID!
  carId: Int
  insuranceId: Int
  date_begin: DateTime
  date_end: DateTime
}

input Car_insuranceInput{
  carId: Int
  insuranceId: Int
  date_begin: DateTime
  date_end: DateTime
}
input Car_insuranceWhereInput{
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  AND: [Car_insuranceWhereInput!]
  OR: [Car_insuranceWhereInput!]
  NOT: [Car_insuranceWhereInput!]
}
enum Car_insuranceOrderByInput {
  id_ASC
  id_DESC
}
type Car_insuranceConnection {
  edges: [Car_insuranceEdge!]
  pageInfo: PageInfo!
}
type Car_insuranceEdge {
  node: Car_insurance!
  cursor: String!
}

type Contract {
  id: ID!
  rentalId: Int
  contract_typeId: Int
  date_begin: DateTime
  date_end: DateTime

}

input ContractInput{
  rentalId: Int
  contract_typeId: Int
  date_begin: DateTime
  date_end: DateTime
}

input ContractWhereInput{
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  AND: [ContractWhereInput!]
  OR: [ContractWhereInput!]
  NOT: [ContractWhereInput!]
}

enum ContractOrderByInput{
  id_ASC
  id_DESC
}

type ContractConnection{
  edges: [ContractEdge!]
  pageInfo: PageInfo!
}

type ContractEdge{
  node: Contract!
  cursor: String!
}

type Contract_type {
  id: ID!
  name: String

}

input Contract_typeInput{
  name: String
}

input Contract_typeWhereInput{
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  AND: [Contract_typeWhereInput!]
  OR: [Contract_typeWhereInput!]
  NOT: [Contract_typeWhereInput!]
}

enum Contract_typeOrderByInput{
  id_ASC
  id_DESC
}

type Contract_typeConnection{
  edges: [Contract_typeEdge!]
  pageInfo: PageInfo!
}

type Contract_typeEdge{
  node: Contract_type!
  cursor: String!
}

type Customer {
  id: ID!
  firstname: String
  lastname: String
  birthday: DateTime
  gender: String
  cni: String
  type: Boolean
  driver_license: String
  city: String
  address: String
  email: String
  phone: String
  company_name: String
}

input CustomerInput{
  firstname: String
  lastname: String
  birthday: DateTime
  gender: String
  cni: String
  type: Boolean
  driver_license: String
  city: String
  address: String
  email: String
  phone: String
  company_name: String
}

input CustomerWhereInput{
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  AND: [CustomerWhereInput!]
  OR: [CustomerWhereInput!]
  NOT: [CustomerWhereInput!]
}

enum CustomerOrderByInput{
  id_ASC
  id_DESC
}

type CustomerConnection{
  edges: [CustomerEdge!]
  pageInfo: PageInfo!
}

type CustomerEdge{
  node: Customer!
  cursor: String!
}

type Image {
  id: ID!
  albumId: Int
  path: String
  album: Album
}

input ImageInput{
  albumId: Int
  file: Upload!
  path: String
}

input ImageWhereInput{
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  AND: [ImageWhereInput!]
  OR: [ImageWhereInput!]
  NOT: [ImageWhereInput!]
}

enum ImageOrderByInput{
  id_ASC
  id_DESC
}

type ImageConnection{
  edges: [ImageEdge!]
  pageInfo: PageInfo!
}

type ImageEdge{
  node: Image!
  cursor: String!
}

type Insurance {
  id: ID!
  name: String
}

input InsuranceInput{
  name: String
}

input InsuranceWhereInput{
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  AND: [InsuranceWhereInput!]
  OR: [InsuranceWhereInput!]
  NOT: [InsuranceWhereInput!]
}

enum InsuranceOrderByInput{
  id_ASC
  id_DESC
}

type InsuranceConnection{
  edges: [InsuranceEdge!]
  pageInfo: PageInfo!
}

type InsuranceEdge{
  node: Insurance!
  cursor: String!
}

type Rental {
  id: ID!
  bookingId: Int
  carId: Int
  customerId: Int
  second_driverId: Int
  date_begin: DateTime
  date_end: DateTime
  booking: Booking
  car: Car
  customer: Customer
  before_rental: Before_rental
  after_rental: After_rental
}

input RentalInput{
  bookingId: Int
  carId: Int
  customerId: Int
  second_driverId: Int
  date_begin: DateTime
  date_end: DateTime

}

input RentalWhereInput{
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  AND: [RentalWhereInput!]
  OR: [RentalWhereInput!]
  NOT: [RentalWhereInput!]
}

enum RentalOrderByInput{
  id_ASC
  id_DESC
}

type RentalConnection{
  edges: [RentalEdge!]
  pageInfo: PageInfo!
}

type RentalEdge{
  node: Rental!
  cursor: String!
}

type Role {
  id: ID!
  title: String
}

input RoleInput{
  title: String
}

input RoleWhereInput{
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  AND: [RoleWhereInput!]
  OR: [RoleWhereInput!]
  NOT: [RoleWhereInput!]
}

enum RoleOrderByInput{
  id_ASC
  id_DESC
}

type RoleConnection{
  edges: [RoleEdge!]
  pageInfo: PageInfo!
}

type RoleEdge{
  node: Role!
  cursor: String!
}
type Status {
  id: ID!
  title: String!
}

input StatusInput{
  title: String!
}
input StatusWhereInput{
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  AND: [StatusWhereInput!]
  OR: [StatusWhereInput!]
  NOT: [StatusWhereInput!]
}
enum StatusOrderByInput {
  id_ASC
  id_DESC
}
type StatusConnection {
  edges: [StatusEdge!]
  pageInfo: PageInfo!
}
type StatusEdge {
  node: Status!
  cursor: String!
}
type AggregateStatus {
  count: Int!
}
type User {
  id: ID!
  firstname: String
  lastname: String
  gender: String
  cni: String
  address: String
  email: String
  phone: String
  roleId: Int
  password: String
  role: Role
}
input UserInput{
  firstname: String!
  lastname: String
  gender: String
  cni: String
  address: String
  email: String!
  phone: String
  roleId: Int
  password: String
}
input UserWhereInput{
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}
enum UserOrderByInput {
  id_ASC
  id_DESC
}
type UserConnection {
  edges: [UserEdge!]
  pageInfo: PageInfo!
}
type UserEdge {
  node: User!
  cursor: String!
}
type AggregateUser {
  count: Int!
}



type PageInfo {
  count: Int
  currentPage: Int
}
